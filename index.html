<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>LAZARO WORLD â€” Pixel City (2D GTA-style)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#0b0f1e;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  canvas{width:100vw;height:100vh;display:block;touch-action:none;image-rendering:pixelated}

  .ui{position:fixed;inset:0;pointer-events:none;color:#fff}
  .top{position:fixed;left:12px;right:12px;top:12px;padding:10px 12px;border-radius:16px;
    background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.14);backdrop-filter:blur(10px);
    font-weight:900;letter-spacing:.6px}
  .hud{position:fixed;left:12px;bottom:12px;max-width:min(640px,78vw);padding:10px 12px;border-radius:16px;
    background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.14);backdrop-filter:blur(10px);
    font-size:12px;line-height:1.35}
  .mini{position:fixed;right:12px;bottom:12px;width:140px;height:140px;border-radius:16px;
    background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.14);backdrop-filter:blur(10px);
    overflow:hidden}

  /* Mobile controls */
  #joy{pointer-events:auto;position:fixed;left:14px;bottom:150px;width:150px;height:150px;border-radius:999px;
    background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);backdrop-filter:blur(8px)}
  #knob{position:absolute;left:50%;top:50%;width:64px;height:64px;transform:translate(-50%,-50%);
    border-radius:999px;background:rgba(255,255,255,.14);border:1px solid rgba(255,255,255,.18)}
  .mBtn{pointer-events:auto;position:fixed;right:14px;border-radius:18px;padding:14px 16px;
    border:1px solid rgba(255,255,255,.14);background:rgba(0,0,0,.35);color:#fff;font-weight:950}
  .mBtn:active{transform:scale(.98)}
  #action{bottom:18px}
  #handbrake{bottom:86px}
  #respawn{top:62px;padding:10px 14px;border-radius:14px}

  @media (pointer:fine){#joy,.mBtn{display:none}}
</style>
</head>
<body>
<canvas id="c"></canvas>

<div class="ui">
  <div class="top" id="top">LAZARO WORLD â€” Pixel City</div>
  <div class="hud" id="hud"></div>
  <canvas class="mini" id="mini" width="140" height="140"></canvas>

  <div id="joy"><div id="knob"></div></div>
  <div class="mBtn" id="respawn">RESPAWN</div>
  <div class="mBtn" id="handbrake">BRAKE</div>
  <div class="mBtn" id="action">ACTION</div>
</div>

<script>
(() => {
  // ---------- Canvas ----------
  const c = document.getElementById("c");
  const ctx = c.getContext("2d", { alpha:false });
  const mini = document.getElementById("mini");
  const mctx = mini.getContext("2d");

  const topEl = document.getElementById("top");
  const hudEl = document.getElementById("hud");

  function resize(){
    const dpr = Math.max(1, Math.min(2, devicePixelRatio||1));
    c.width = (innerWidth*dpr)|0;
    c.height = (innerHeight*dpr)|0;
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener("resize", resize); resize();

  // ---------- World (tile map) ----------
  // Mario-ish pixel vibe, GTA-ish open world: top-down tile city
  const TILE = 16;
  const MAP_W = 220;   // tiles
  const MAP_H = 160;   // tiles
  const WORLD_W = MAP_W*TILE;
  const WORLD_H = MAP_H*TILE;

  // Tile types:
  // 0 = grass, 1 = road, 2 = sidewalk, 3 = water, 4 = building (solid)
  const map = new Uint8Array(MAP_W*MAP_H);

  const idx = (x,y)=> y*MAP_W + x;
  const inb = (x,y)=> x>=0 && y>=0 && x<MAP_W && y<MAP_H;

  // Procedural city: roads grid + blocks + water strip
  function gen(){
    map.fill(0);

    // water band
    for(let y=0;y<MAP_H;y++){
      for(let x=0;x<MAP_W;x++){
        if(x>MAP_W-28) map[idx(x,y)] = 3;
      }
    }

    // main roads
    for(let y=0;y<MAP_H;y++){
      for(let x=0;x<MAP_W-28;x++){
        if(x%12===0 || y%12===0) map[idx(x,y)] = 1;
      }
    }

    // sidewalks around roads
    for(let y=1;y<MAP_H-1;y++){
      for(let x=1;x<MAP_W-29;x++){
        if(map[idx(x,y)]===0){
          const nearRoad =
            map[idx(x+1,y)]===1 || map[idx(x-1,y)]===1 || map[idx(x,y+1)]===1 || map[idx(x,y-1)]===1;
          if(nearRoad) map[idx(x,y)] = 2;
        }
      }
    }

    // buildings in blocks (solid)
    for(let y=2;y<MAP_H-2;y++){
      for(let x=2;x<MAP_W-30;x++){
        if(map[idx(x,y)]===0){
          // fill some building lots
          if(Math.random()<0.42){
            // small building rectangle
            const w = 2 + (Math.random()*5|0);
            const h = 2 + (Math.random()*5|0);
            // keep away from roads
            let ok=true;
            for(let yy=y; yy<y+h; yy++){
              for(let xx=x; xx<x+w; xx++){
                if(!inb(xx,yy) || map[idx(xx,yy)]!==0) ok=false;
              }
            }
            if(ok){
              for(let yy=y; yy<y+h; yy++){
                for(let xx=x; xx<x+w; xx++){
                  map[idx(xx,yy)] = 4;
                }
              }
            }
          }
        }
      }
    }

    // small park area
    for(let y=24;y<44;y++){
      for(let x=24;x<54;x++){
        map[idx(x,y)] = 0;
      }
    }
  }
  gen();

  function tileAt(px,py){
    const tx = (px/TILE)|0;
    const ty = (py/TILE)|0;
    if(!inb(tx,ty)) return 4;
    return map[idx(tx,ty)];
  }
  function solidAt(px,py){
    const t = tileAt(px,py);
    return (t===4 || t===3); // buildings & water solid
  }

  // ---------- Input ----------
  const keys = new Set();
  addEventListener("keydown", e=>{
    const k = e.key.toLowerCase();
    keys.add(k);
    if(k==="e") action();
    if(k==="r") respawn();
    if(k===" ") handbrake = true;
  });
  addEventListener("keyup", e=>{
    const k = e.key.toLowerCase();
    keys.delete(k);
    if(k===" ") handbrake = false;
  });

  let pointer = {x:innerWidth/2,y:innerHeight/2};
  addEventListener("pointermove", e=>{ pointer.x=e.clientX; pointer.y=e.clientY; });

  // Mobile joystick
  const joy = document.getElementById("joy");
  const knob = document.getElementById("knob");
  let joyState = {id:null,active:false,dx:0,dy:0};

  function setKnob(dx,dy){
    const max=46;
    knob.style.transform = `translate(calc(-50% + ${dx*max}px), calc(-50% + ${dy*max}px))`;
  }
  function joyRect(){ return joy.getBoundingClientRect(); }
  joy.addEventListener("pointerdown", e=>{
    joyState.id=e.pointerId; joyState.active=true; joy.setPointerCapture(e.pointerId);
  });
  joy.addEventListener("pointermove", e=>{
    if(!joyState.active || e.pointerId!==joyState.id) return;
    const r=joyRect(); const cx=r.left+r.width/2, cy=r.top+r.height/2;
    const vx=e.clientX-cx, vy=e.clientY-cy;
    const max=r.width/2-10;
    joyState.dx = Math.max(-1,Math.min(1,vx/max));
    joyState.dy = Math.max(-1,Math.min(1,vy/max));
    setKnob(joyState.dx, joyState.dy);
  });
  function joyReset(){ joyState.active=false; joyState.id=null; joyState.dx=0; joyState.dy=0; setKnob(0,0); }
  joy.addEventListener("pointerup", e=>{ if(e.pointerId===joyState.id) joyReset(); });
  joy.addEventListener("pointercancel", joyReset);

  // Mobile buttons
  document.getElementById("action").addEventListener("click", ()=>action());
  document.getElementById("respawn").addEventListener("click", ()=>respawn());
  let handbrake=false;
  document.getElementById("handbrake").addEventListener("pointerdown", ()=>handbrake=true);
  document.getElementById("handbrake").addEventListener("pointerup", ()=>handbrake=false);

  // ---------- Entities ----------
  const player = {
    x: 520, y: 520, r: 7,
    hp: 100,
    money: 0,
    wanted: 0,
    inCar: false
  };

  const cars = [];
  function spawnCar(x,y,color){
    cars.push({x,y,w:22,h:14,a:0,spd:0,color,health:100,driver:false});
  }
  // spawn some cars on roads
  for(let i=0;i<18;i++){
    spawnCar( rand(100,WORLD_W-500), rand(100,WORLD_H-100), ["#ff4d6d","#3cffcc","#ffd166","#7b3cff"][i%4] );
  }

  const cops = [];
  function spawnCop(x,y){
    cops.push({x,y,r:7,spd:110,hp:40,cd:0});
  }

  // Mission marker
  const mission = { x: 880, y: 300, r: 16, active:true };

  function rand(a,b){ return a + Math.random()*(b-a); }

  // ---------- Camera ----------
  const cam = {x:0,y:0};
  function updateCam(){
    cam.x = Math.max(0, Math.min(WORLD_W-innerWidth, player.x - innerWidth/2));
    cam.y = Math.max(0, Math.min(WORLD_H-innerHeight, player.y - innerHeight/2));
  }

  function screenToWorld(sx,sy){ return {x:sx+cam.x, y:sy+cam.y}; }

  // ---------- Game actions ----------
  function nearestCar(){
    let best=null, bd=1e9;
    for(const car of cars){
      const d = Math.hypot(car.x-player.x, car.y-player.y);
      if(d<bd){ bd=d; best=car; }
    }
    return {car:best, dist:bd};
  }

  function action(){
    // Enter/Exit car or do mission
    const dM = Math.hypot(player.x-mission.x, player.y-mission.y);
    if(mission.active && dM < mission.r+10){
      mission.active=false;
      player.money += 250;
      player.wanted = Math.min(5, player.wanted + 1);
      toast("MISSION DONE +$250 (Wanted +1)");
      return;
    }

    const {car, dist} = nearestCar();
    if(!player.inCar){
      if(car && dist < 26){
        player.inCar = true;
        car.driver = true;
        toast("ENTER CAR");
      } else {
        // cause "chaos" (simple punch) -> wanted
        player.wanted = Math.min(5, player.wanted + 0.5);
        toast("CHAOS! (Wanted up)");
      }
    } else {
      // exit current car
      for(const car of cars){
        if(car.driver){
          car.driver=false;
          player.inCar=false;
          player.x = car.x + 28;
          player.y = car.y;
          toast("EXIT CAR");
          break;
        }
      }
    }
  }

  function respawn(){
    player.x=520; player.y=520; player.hp=100;
    player.wanted = Math.max(0, player.wanted-1);
    // exit car if in one
    for(const car of cars) car.driver=false;
    player.inCar=false;
    toast("RESPAWN");
  }

  // ---------- Simple toast ----------
  let toastMsg="", toastT=0;
  function toast(m){ toastMsg=m; toastT=1.3; }

  // ---------- Physics helpers ----------
  function moveWithCollide(obj, dx, dy, radius){
    // Try X then Y (simple AABB-ish collision against solid tiles)
    let nx=obj.x+dx, ny=obj.y;

    // X
    if(!collidesCircle(nx, ny, radius)) obj.x=nx;

    // Y
    nx=obj.x; ny=obj.y+dy;
    if(!collidesCircle(nx, ny, radius)) obj.y=ny;
  }

  function collidesCircle(x,y,r){
    // sample around circle
    const pts = [
      [x+r,y],[x-r,y],[x,y+r],[x,y-r],
      [x+r*0.7,y+r*0.7],[x-r*0.7,y+r*0.7],[x+r*0.7,y-r*0.7],[x-r*0.7,y-r*0.7]
    ];
    for(const [px,py] of pts){
      if(solidAt(px,py)) return true;
    }
    return false;
  }

  // ---------- Update loop ----------
  let last=performance.now();
  function tick(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last=now;

    update(dt);
    render(now/1000);

    requestAnimationFrame(tick);
  }

  function update(dt){
    // Wanted decay
    player.wanted = Math.max(0, player.wanted - dt*0.03);

    // Spawn cops based on wanted
    const targetCops = Math.floor(player.wanted*2);
    while(cops.length < targetCops){
      spawnCop(player.x + rand(-280,280), player.y + rand(-280,280));
    }
    while(cops.length > targetCops) cops.pop();

    // Control
    let mx=0,my=0;
    if(keys.has("w")||keys.has("arrowup")) my-=1;
    if(keys.has("s")||keys.has("arrowdown")) my+=1;
    if(keys.has("a")||keys.has("arrowleft")) mx-=1;
    if(keys.has("d")||keys.has("arrowright")) mx+=1;

    mx += joyState.dx;
    my += joyState.dy;

    const m = Math.hypot(mx,my);
    if(m>1e-6){ mx/=m; my/=m; }

    // If in car: drive
    if(player.inCar){
      const car = cars.find(c=>c.driver);
      if(car){
        // steering uses pointer direction (desktop) or movement vector (mobile)
        let steerX = mx, steerY = my;
        if(matchMedia("(pointer:fine)").matches){
          const w = screenToWorld(pointer.x, pointer.y);
          steerX = w.x - car.x;
          steerY = w.y - car.y;
          const d = Math.hypot(steerX, steerY) || 1;
          steerX/=d; steerY/=d;
        }
        // accelerate
        car.spd += 520*dt;
        car.spd *= (handbrake ? (1-6*dt) : (1-2.2*dt));
        car.spd = Math.min(car.spd, handbrake?120:260);

        // turn toward steer vector
        const targetA = Math.atan2(steerY, steerX);
        let da = targetA - car.a;
        while(da>Math.PI) da-=Math.PI*2;
        while(da<-Math.PI) da+=Math.PI*2;
        car.a += Math.max(-3.4*dt, Math.min(3.4*dt, da));

        // move car with collision
        const dx = Math.cos(car.a)*car.spd*dt;
        const dy = Math.sin(car.a)*car.spd*dt;
        moveWithCollide(car, dx, dy, 10);

        // player rides
        player.x = car.x;
        player.y = car.y;

        // Chaos by driving on sidewalks/buildings increases wanted
        const t = tileAt(car.x, car.y);
        if(t===2) player.wanted = Math.min(5, player.wanted + dt*0.05);
        if(t===4) player.wanted = Math.min(5, player.wanted + dt*0.08);
      }
    } else {
      // Walk
      const spd = 140;
      moveWithCollide(player, mx*spd*dt, my*spd*dt, player.r);
    }

    // Cop AI chase
    for(const cop of cops){
      const dx = player.x - cop.x;
      const dy = player.y - cop.y;
      const d = Math.hypot(dx,dy) || 1;
      const vx = (dx/d)*cop.spd;
      const vy = (dy/d)*cop.spd;
      moveWithCollide(cop, vx*dt, vy*dt, cop.r);

      // "damage" if close
      if(d < 18){
        player.hp = Math.max(0, player.hp - 18*dt);
        if(player.hp<=0){
          toast("WASTED ðŸ’€");
          respawn();
        }
      }
    }

    updateCam();

    // Mission completion check (also by walking into it)
    if(mission.active){
      const dM = Math.hypot(player.x-mission.x, player.y-mission.y);
      if(dM < mission.r+8){
        mission.active=false;
        player.money += 250;
        player.wanted = Math.min(5, player.wanted + 1);
        toast("MISSION DONE +$250 (Wanted +1)");
      }
    }

    // Toast timer
    if(toastT>0) toastT -= dt;
  }

  // ---------- Render ----------
  function render(t){
    ctx.fillStyle="#0b0f1e";
    ctx.fillRect(0,0,innerWidth,innerHeight);

    ctx.save();
    ctx.translate(-cam.x, -cam.y);

    // Tiles (simple pixel palette)
    for(let ty=0; ty<MAP_H; ty++){
      const y = ty*TILE;
      // cull rows not visible
      if(y > cam.y+innerHeight+TILE || y+TILE < cam.y-TILE) continue;

      for(let tx=0; tx<MAP_W; tx++){
        const x = tx*TILE;
        if(x > cam.x+innerWidth+TILE || x+TILE < cam.x-TILE) continue;

        const tId = map[idx(tx,ty)];
        if(tId===0){ ctx.fillStyle="#1a2b1f"; }        // grass
        else if(tId===1){ ctx.fillStyle="#2b2f3a"; }   // road
        else if(tId===2){ ctx.fillStyle="#3a3f4b"; }   // sidewalk
        else if(tId===3){ ctx.fillStyle="#0b2a4a"; }   // water
        else { ctx.fillStyle="#18141f"; }              // building
        ctx.fillRect(x,y,TILE,TILE);

        // tiny pixel detail
        if(tId===1 && ((tx+ty)&3)===0){
          ctx.fillStyle="rgba(255,255,255,0.06)";
          ctx.fillRect(x+7,y+7,2,2);
        }
        if(tId===0 && ((tx*13+ty*7)&15)===0){
          ctx.fillStyle="rgba(0,0,0,0.12)";
          ctx.fillRect(x+4,y+4,2,2);
        }
      }
    }

    // Mission marker
    if(mission.active){
      ctx.save();
      ctx.translate(mission.x, mission.y);
      const pulse = 0.6 + 0.4*Math.sin(t*6);
      ctx.strokeStyle="rgba(60,255,210,0.9)";
      ctx.lineWidth=3;
      ctx.beginPath(); ctx.arc(0,0, mission.r + pulse*5, 0, Math.PI*2); ctx.stroke();
      ctx.fillStyle="rgba(60,255,210,0.35)";
      ctx.beginPath(); ctx.arc(0,0, mission.r, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    // Cars
    for(const car of cars){
      ctx.save();
      ctx.translate(car.x, car.y);
      ctx.rotate(car.a);

      // body
      ctx.fillStyle=car.color;
      rectPix(-11,-7,22,14);

      // windshield stripe
      ctx.fillStyle="rgba(255,255,255,0.55)";
      rectPix(-6,-3,12,6);

      // wheels
      ctx.fillStyle="rgba(0,0,0,0.6)";
      rectPix(-10,-9,6,3);
      rectPix(4,-9,6,3);
      rectPix(-10,6,6,3);
      rectPix(4,6,6,3);

      // driver indicator
      if(car.driver){
        ctx.fillStyle="rgba(60,255,210,0.9)";
        rectPix(-2,-2,4,4);
      }
      ctx.restore();
    }

    // Cops
    for(const cop of cops){
      ctx.save();
      ctx.translate(cop.x, cop.y);
      ctx.fillStyle="#3b82f6";
      circlePix(0,0,cop.r);
      ctx.fillStyle="rgba(255,255,255,0.7)";
      rectPix(-4,-8,8,3);
      ctx.restore();
    }

    // Player (pixel character)
    ctx.save();
    ctx.translate(player.x, player.y);
    // shadow
    ctx.fillStyle="rgba(0,0,0,0.25)";
    circlePix(0,8,6);
    // body
    ctx.fillStyle="#3cffcc";
    rectPix(-5,-8,10,12);
    // head
    ctx.fillStyle="#ffd6a5";
    rectPix(-4,-14,8,6);
    // visor
    ctx.fillStyle="rgba(0,0,0,0.5)";
    rectPix(-3,-12,6,2);
    ctx.restore();

    ctx.restore(); // world

    // UI text
    topEl.textContent =
      `LAZARO WORLD â€” HP ${player.hp|0} â€¢ $${player.money} â€¢ Wanted ${player.wanted.toFixed(1)} â€¢ ` +
      `${player.inCar ? "IN CAR (E/ACTION to exit)" : "ON FOOT (E/ACTION to enter car)"}`;

    hudEl.innerHTML =
      `<b>Desktop:</b> WASD move â€¢ E action â€¢ R respawn â€¢ Space brake<br/>`+
      `<b>Phone:</b> joystick move â€¢ ACTION enter/exit/mission â€¢ BRAKE<br/>`+
      `<b>Mission:</b> go to glowing circle for cash. Causing chaos increases Wanted.`;

    // Toast
    if(toastT>0){
      ctx.save();
      ctx.globalAlpha = Math.min(1, toastT);
      ctx.fillStyle="rgba(0,0,0,0.55)";
      const w = Math.min(520, innerWidth-40);
      const x = (innerWidth-w)/2;
      ctx.fillRect(x, 60, w, 44);
      ctx.fillStyle="rgba(255,255,255,0.95)";
      ctx.font="900 15px system-ui";
      ctx.textAlign="center";
      ctx.fillText(toastMsg, innerWidth/2, 88);
      ctx.restore();
    }

    // Minimap
    drawMini();
  }

  function rectPix(x,y,w,h){
    // crisp pixel edges
    ctx.fillRect((x)|0,(y)|0,(w)|0,(h)|0);
  }
  function circlePix(x,y,r){
    ctx.beginPath();
    ctx.arc(x|0,y|0,r,0,Math.PI*2);
    ctx.fill();
  }

  function drawMini(){
    // show a small part of the world
    mctx.clearRect(0,0,mini.width,mini.height);
    mctx.fillStyle="rgba(0,0,0,0.25)";
    mctx.fillRect(0,0,mini.width,mini.height);

    const scaleX = mini.width / WORLD_W;
    const scaleY = mini.height / WORLD_H;

    // draw roads/buildings simplified
    // (fast sampling)
    const step = 6;
    for(let y=0;y<MAP_H;y+=step){
      for(let x=0;x<MAP_W;x+=step){
        const t = map[idx(x,y)];
        if(t===1) mctx.fillStyle="rgba(255,255,255,0.10)";
        else if(t===4) mctx.fillStyle="rgba(0,0,0,0.18)";
        else if(t===3) mctx.fillStyle="rgba(60,160,255,0.12)";
        else continue;
        mctx.fillRect(x*TILE*scaleX, y*TILE*scaleY, step*TILE*scaleX, step*TILE*scaleY);
      }
    }

    // player
    mctx.fillStyle="rgba(60,255,210,0.9)";
    mctx.fillRect(player.x*scaleX-2, player.y*scaleY-2, 4, 4);

    // cops
    mctx.fillStyle="rgba(59,130,246,0.9)";
    for(const cop of cops){
      mctx.fillRect(cop.x*scaleX-1, cop.y*scaleY-1, 2, 2);
    }

    // mission
    if(mission.active){
      mctx.strokeStyle="rgba(60,255,210,0.7)";
      mctx.beginPath();
      mctx.arc(mission.x*scaleX, mission.y*scaleY, 6, 0, Math.PI*2);
      mctx.stroke();
    }
  }

  // Start
  updateCam();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
