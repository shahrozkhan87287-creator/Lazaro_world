<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>LAZARO WORLD â€” Pixel GTA</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#081021;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  canvas{width:100vw;height:100vh;display:block;touch-action:none;image-rendering:pixelated}

  .ui{position:fixed;inset:0;pointer-events:none;color:#fff}
  .top{position:fixed;left:12px;right:12px;top:12px;padding:10px 12px;border-radius:16px;
    background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.14);backdrop-filter:blur(10px);
    font-weight:900;letter-spacing:.6px}
  .hud{position:fixed;left:12px;bottom:12px;max-width:min(720px,78vw);padding:10px 12px;border-radius:16px;
    background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.14);backdrop-filter:blur(10px);
    font-size:12px;line-height:1.35}
  .mini{position:fixed;right:12px;bottom:12px;width:160px;height:160px;border-radius:16px;
    background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.14);backdrop-filter:blur(10px);
    overflow:hidden}

  /* Shop modal */
  .modal{
    pointer-events:auto;
    position:fixed;left:12px;right:12px;top:72px;max-width:520px;margin:auto;
    border-radius:18px;background:rgba(0,0,0,.65);border:1px solid rgba(255,255,255,.14);
    backdrop-filter:blur(12px);padding:12px;display:none
  }
  .modal h3{margin:0 0 8px 0}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .btn{
    pointer-events:auto;
    border-radius:14px;padding:10px 12px;
    border:1px solid rgba(255,255,255,.16);
    background:rgba(255,255,255,.06);
    color:#fff;font-weight:900
  }
  .btn:active{transform:scale(.99)}
  .muted{opacity:.8;font-size:12px}

  /* Mobile controls */
  #joy{pointer-events:auto;position:fixed;left:14px;bottom:150px;width:150px;height:150px;border-radius:999px;
    background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);backdrop-filter:blur(8px)}
  #knob{position:absolute;left:50%;top:50%;width:64px;height:64px;transform:translate(-50%,-50%);
    border-radius:999px;background:rgba(255,255,255,.14);border:1px solid rgba(255,255,255,.18)}
  .mBtn{pointer-events:auto;position:fixed;right:14px;border-radius:18px;padding:14px 16px;
    border:1px solid rgba(255,255,255,.14);background:rgba(0,0,0,.35);color:#fff;font-weight:950}
  .mBtn:active{transform:scale(.98)}
  #action{bottom:18px}
  #brake{bottom:86px}
  #respawn{top:62px;padding:10px 14px;border-radius:14px}

  @media (pointer:fine){#joy,.mBtn{display:none}}
</style>
</head>
<body>
<canvas id="c"></canvas>

<div class="ui">
  <div class="top" id="top">LAZARO WORLD â€” Pixel GTA</div>
  <div class="hud" id="hud"></div>
  <canvas class="mini" id="mini" width="160" height="160"></canvas>

  <div class="modal" id="shopModal">
    <h3 id="shopTitle">SHOP</h3>
    <div class="muted" id="shopHint">Press ESC or Close</div>
    <div class="row" style="margin-top:10px">
      <button class="btn" id="buyHP">Buy Health (+30) â€” $100</button>
      <button class="btn" id="bribe">Bribe (Wanted -1) â€” $200</button>
      <button class="btn" id="repair">Repair Car (+40) â€” $150</button>
      <button class="btn" id="closeShop">Close</button>
    </div>
  </div>

  <div id="joy"><div id="knob"></div></div>
  <div class="mBtn" id="respawn">RESPAWN</div>
  <div class="mBtn" id="brake">BRAKE</div>
  <div class="mBtn" id="action">ACTION</div>
</div>

<script>
(() => {
  // =========================
  // Canvas
  // =========================
  const c = document.getElementById("c");
  const ctx = c.getContext("2d", { alpha:false });
  const mini = document.getElementById("mini");
  const mctx = mini.getContext("2d");
  const topEl = document.getElementById("top");
  const hudEl = document.getElementById("hud");

  function resize(){
    const dpr = Math.max(1, Math.min(2, devicePixelRatio||1));
    c.width = (innerWidth*dpr)|0;
    c.height = (innerHeight*dpr)|0;
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener("resize", resize); resize();

  // =========================
  // Helpers
  // =========================
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rand=(a,b)=>a+Math.random()*(b-a);
  const randi=(a,b)=>(a+Math.random()*(b-a+1))|0;

  function rectPix(x,y,w,h){ ctx.fillRect(x|0,y|0,w|0,h|0); }
  function circlePix(x,y,r){ ctx.beginPath(); ctx.arc((x|0),(y|0),r,0,Math.PI*2); ctx.fill(); }

  // =========================
  // Palette (GTA1-ish)
  // =========================
  const PAL = {
    sky:"#081021",
    grassA:"#163021", grassB:"#1a3a26",
    roadA:"#2b2f3a",  roadB:"#242836",
    sideA:"#3a3f4b",  sideB:"#343a45",
    waterA:"#0b2a4a", waterB:"#083055",
    shadow:"rgba(0,0,0,0.26)",
    shadowDeep:"rgba(0,0,0,0.40)",
    neonA:"rgba(60,255,210,0.9)",
    neonB:"rgba(255,77,109,0.9)",
    text:"rgba(255,255,255,0.95)",
  };

  // =========================
  // World
  // =========================
  const TILE = 16;
  const MAP_W = 260, MAP_H = 180;
  const WORLD_W = MAP_W*TILE, WORLD_H = MAP_H*TILE;

  // tiles: 0 grass, 1 road, 2 sidewalk, 3 water, 4 building footprint, 5 alley dirt
  const map = new Uint8Array(MAP_W*MAP_H);
  const idx = (x,y)=> y*MAP_W + x;
  const inb = (x,y)=> x>=0 && y>=0 && x<MAP_W && y<MAP_H;

  const buildings = [];
  const lamps = [];
  const roadNodes = [];
  const shops = []; // {x,y,r,name}

  function tileAt(px,py){
    const tx=(px/TILE)|0, ty=(py/TILE)|0;
    if(!inb(tx,ty)) return 4;
    return map[idx(tx,ty)];
  }
  function solidAt(px,py){
    const t = tileAt(px,py);
    return (t===4 || t===3);
  }
  function isWalkable(px,py){
    const t = tileAt(px,py);
    return (t===0 || t===1 || t===2 || t===5); // not water/building
  }

  function gen(){
    map.fill(0);
    buildings.length=0;
    lamps.length=0;
    roadNodes.length=0;
    shops.length=0;

    // Water / docks on east
    for(let y=0;y<MAP_H;y++){
      for(let x=MAP_W-38;x<MAP_W;x++){
        map[idx(x,y)] = 3;
      }
    }
    for(let y=10;y<MAP_H-10;y++){
      for(let x=MAP_W-45;x<MAP_W-38;x++){
        map[idx(x,y)] = 2;
      }
    }

    // Road grid
    const major = 16, minor = 32;
    for(let y=0;y<MAP_H;y++){
      for(let x=0;x<MAP_W-38;x++){
        if(x%major===0 || y%major===0) map[idx(x,y)] = 1;
        if(x%minor===0 || y%minor===0){
          if(inb(x+1,y)) map[idx(x+1,y)] = 1;
          if(inb(x,y+1)) map[idx(x,y+1)] = 1;
        }
      }
    }

    // Sidewalks near roads
    for(let y=1;y<MAP_H-1;y++){
      for(let x=1;x<MAP_W-39;x++){
        if(map[idx(x,y)]===0){
          const nearRoad =
            map[idx(x+1,y)]===1 || map[idx(x-1,y)]===1 || map[idx(x,y+1)]===1 || map[idx(x,y-1)]===1;
          if(nearRoad) map[idx(x,y)] = 2;
        }
      }
    }

    // Park
    for(let y=24;y<50;y++){
      for(let x=22;x<62;x++){
        map[idx(x,y)] = 0;
      }
    }

    // Alleys
    for(let y=10;y<MAP_H-10;y++){
      for(let x=10;x<MAP_W-55;x++){
        if(map[idx(x,y)]===0 && Math.random()<0.013){
          const len=randi(10,35);
          const dir=Math.random()<0.5?0:1;
          for(let i=0;i<len;i++){
            const xx = x + (dir===0?i:0);
            const yy = y + (dir===1?i:0);
            if(!inb(xx,yy)) break;
            if(map[idx(xx,yy)]===0) map[idx(xx,yy)] = 5;
          }
        }
      }
    }

    // Building lots
    const lotTries = 7800;
    for(let i=0;i<lotTries;i++){
      const x = randi(3, MAP_W-50);
      const y = randi(3, MAP_H-4);
      const base = map[idx(x,y)];
      if(base!==0 && base!==5) continue;

      let near=false;
      for(let oy=-1; oy<=1; oy++){
        for(let ox=-1; ox<=1; ox++){
          if(!inb(x+ox,y+oy)) continue;
          const t = map[idx(x+ox,y+oy)];
          if(t===1||t===2) near=true;
        }
      }
      if(near) continue;

      const w = randi(3, 12);
      const h = randi(3, 12);

      let ok=true;
      for(let yy=y; yy<y+h; yy++){
        for(let xx=x; xx<x+w; xx++){
          if(!inb(xx,yy)) { ok=false; break; }
          const t = map[idx(xx,yy)];
          if(!(t===0 || t===5)) { ok=false; break; }
        }
        if(!ok) break;
      }
      if(!ok) continue;

      for(let yy=y; yy<y+h; yy++){
        for(let xx=x; xx<x+w; xx++){
          map[idx(xx,yy)] = 4;
        }
      }

      const height = randi(18, 68);
      const style = randi(0, 4);
      const roof = style===0 ? "#2a2d3a" :
                   style===1 ? "#2b2340" :
                   style===2 ? "#3a2b35" :
                   style===3 ? "#243245" : "#2a2a2a";
      const wall = style===0 ? "#141a2a" :
                   style===1 ? "#1b1430" :
                   style===2 ? "#221220" :
                   style===3 ? "#111c2c" : "#161616";
      const detail = (Math.random()<0.62) ? "windows" : (Math.random()<0.5 ? "neon" : "blank");
      const lift = Math.min(12, (height*0.22)|0);

      buildings.push({ x:x*TILE, y:y*TILE, w:w*TILE, h:h*TILE, height, roof, wall, detail, lift });
    }

    // Towers
    for(let i=0;i<22;i++){
      const bx=randi(25, MAP_W-80), by=randi(12, MAP_H-40);
      const w=randi(12, 22), h=randi(12, 22);
      let ok=true;
      for(let yy=by; yy<by+h; yy++){
        for(let xx=bx; xx<bx+w; xx++){
          if(!inb(xx,yy) || map[idx(xx,yy)]===3) ok=false;
        }
      }
      if(!ok) continue;
      for(let yy=by; yy<by+h; yy++){
        for(let xx=bx; xx<bx+w; xx++){
          if(map[idx(xx,yy)]!==3) map[idx(xx,yy)] = 4;
        }
      }
      const height=randi(60, 110);
      buildings.push({ x:bx*TILE, y:by*TILE, w:w*TILE, h:h*TILE, height, roof:"#2b2f3a", wall:"#0f1422", detail:"windows", lift:Math.min(14,(height*0.22)|0) });
    }

    // Lamps
    for(let y=2;y<MAP_H-2;y++){
      for(let x=2;x<MAP_W-40;x++){
        if(map[idx(x,y)]===2 && (x%8===0) && (y%8===0) && Math.random()<0.22){
          lamps.push({x:x*TILE+8, y:y*TILE+8});
        }
      }
    }

    // Road nodes (ONLY real road tiles)
    for(let y=2;y<MAP_H-2;y+=2){
      for(let x=2;x<MAP_W-40;x+=2){
        if(map[idx(x,y)]===1 && (x%4===0 || y%4===0)){
          roadNodes.push({x:x*TILE+8, y:y*TILE+8});
        }
      }
    }

    // Add a few shops on sidewalk near roads
    function placeShop(name){
      for(let tries=0; tries<2000; tries++){
        const x=randi(10, MAP_W-60), y=randi(10, MAP_H-10);
        if(map[idx(x,y)]!==2) continue; // sidewalk
        // must be near road
        const near = (map[idx(x+1,y)]===1 || map[idx(x-1,y)]===1 || map[idx(x,y+1)]===1 || map[idx(x,y-1)]===1);
        if(!near) continue;
        const wx=x*TILE+8, wy=y*TILE+8;
        // not too close to another shop
        let ok=true;
        for(const s of shops){
          if(Math.hypot(s.x-wx, s.y-wy) < 200) ok=false;
        }
        if(!ok) continue;
        shops.push({x:wx, y:wy, r:18, name});
        return;
      }
    }
    placeShop("BODEGA");
    placeShop("MED CLINIC");
    placeShop("CUSTOM GARAGE");
  }

  gen();

  // =========================
  // Input
  // =========================
  const keys = new Set();
  addEventListener("keydown", e=>{
    const k=e.key.toLowerCase();
    keys.add(k);
    if(k==="e") action();
    if(k==="r") respawn();
    if(k===" ") handbrake=true;
    if(k==="g") { gen(); hardRespawnSafe(); toast("CITY REMIX âœ…"); }
    if(k==="escape") closeShop();
  });
  addEventListener("keyup", e=>{
    const k=e.key.toLowerCase();
    keys.delete(k);
    if(k===" ") handbrake=false;
  });

  let pointer={x:innerWidth/2,y:innerHeight/2};
  addEventListener("pointermove", e=>{ pointer.x=e.clientX; pointer.y=e.clientY; });

  // Mobile joystick
  const joy = document.getElementById("joy");
  const knob = document.getElementById("knob");
  let joyState={id:null,active:false,dx:0,dy:0};
  function setKnob(dx,dy){
    const max=46;
    knob.style.transform = `translate(calc(-50% + ${dx*max}px), calc(-50% + ${dy*max}px))`;
  }
  function joyRect(){ return joy.getBoundingClientRect(); }
  joy.addEventListener("pointerdown", e=>{
    joyState.id=e.pointerId; joyState.active=true; joy.setPointerCapture(e.pointerId);
  });
  joy.addEventListener("pointermove", e=>{
    if(!joyState.active || e.pointerId!==joyState.id) return;
    const r=joyRect(); const cx=r.left+r.width/2, cy=r.top+r.height/2;
    const vx=e.clientX-cx, vy=e.clientY-cy;
    const max=r.width/2-10;
    joyState.dx = clamp(vx/max, -1, 1);
    joyState.dy = clamp(vy/max, -1, 1);
    setKnob(joyState.dx, joyState.dy);
  });
  function joyReset(){ joyState.active=false; joyState.id=null; joyState.dx=0; joyState.dy=0; setKnob(0,0); }
  joy.addEventListener("pointerup", e=>{ if(e.pointerId===joyState.id) joyReset(); });
  joy.addEventListener("pointercancel", joyReset);

  document.getElementById("action").addEventListener("click", ()=>action());
  document.getElementById("respawn").addEventListener("click", ()=>respawn());
  let handbrake=false;
  document.getElementById("brake").addEventListener("pointerdown", ()=>handbrake=true);
  document.getElementById("brake").addEventListener("pointerup", ()=>handbrake=false);

  // =========================
  // Entities
  // =========================
  const player = { x:520, y:520, r:7, hp:100, money:0, wanted:0, inCar:false };

  const cars = [];
  const cops = [];
  const particles = [];

  const CAR_STYLES = [
    { name:"Coupe",  body:"#ff4d6d", roof:"rgba(255,255,255,0.55)", trim:"rgba(0,0,0,0.55)" },
    { name:"Taxi",   body:"#ffd166", roof:"rgba(255,255,255,0.60)", trim:"rgba(0,0,0,0.55)" },
    { name:"Neon",   body:"#3cffcc", roof:"rgba(255,255,255,0.55)", trim:"rgba(0,0,0,0.55)" },
    { name:"Van",    body:"#9b87f5", roof:"rgba(255,255,255,0.52)", trim:"rgba(0,0,0,0.55)" },
  ];

  function nearestRoadNode(x,y){
    let best=null, bd=1e18;
    for(let i=0;i<roadNodes.length;i+=6){ // skip some for speed
      const n=roadNodes[i];
      const d=(n.x-x)*(n.x-x)+(n.y-y)*(n.y-y);
      if(d<bd){ bd=d; best=n; }
    }
    // If we skipped too much, do a quick local refinement
    if(!best) return roadNodes[0] || {x:520,y:520};
    return best;
  }

  function safeSpawnPoint(){
    // Prefer sidewalk near road
    for(let tries=0; tries<5000; tries++){
      const tx = randi(10, MAP_W-60);
      const ty = randi(10, MAP_H-10);
      const t = map[idx(tx,ty)];
      if(t!==2 && t!==0) continue; // sidewalk/grass only
      // near road
      const near = (map[idx(tx+1,ty)]===1 || map[idx(tx-1,ty)]===1 || map[idx(tx,ty+1)]===1 || map[idx(tx,ty-1)]===1);
      if(!near) continue;
      const x = tx*TILE+8, y=ty*TILE+8;
      if(!solidAt(x,y)) return {x,y};
    }
    // fallback to a road node
    const n = roadNodes[(Math.random()*roadNodes.length)|0];
    return n ? {x:n.x, y:n.y} : {x:520, y:520};
  }

  function hardRespawnSafe(){
    const p = safeSpawnPoint();
    player.x=p.x; player.y=p.y;
    // also avoid spawning inside a car
    player.x += rand(-18,18);
    player.y += rand(-18,18);
  }

  function spawnCar(x,y,style){
    cars.push({
      x,y,w:24,h:14,a:Math.random()*Math.PI*2,spd:0,
      style, health:100, driver:false, skid:0,
      ai: true,
      node: (Math.random()*roadNodes.length)|0
    });
  }

  // Spawn traffic ON roads
  for(let i=0;i<36;i++){
    const style = CAR_STYLES[i%CAR_STYLES.length];
    const n = roadNodes[(Math.random()*roadNodes.length)|0];
    if(n) spawnCar(n.x+rand(-6,6), n.y+rand(-6,6), style);
  }

  function spawnCop(x,y){
    cops.push({x,y,r:7,spd:135,hp:60});
  }

  // Missions
  const missions = [];
  function newMission(){
    const n = roadNodes[(Math.random()*roadNodes.length)|0];
    missions.push({x:n.x,y:n.y,r:18,type:"delivery",t:0});
  }
  for(let i=0;i<3;i++) newMission();

  // =========================
  // Camera
  // =========================
  const cam = {x:0,y:0};
  function updateCam(){
    cam.x = clamp(player.x - innerWidth/2, 0, WORLD_W-innerWidth);
    cam.y = clamp(player.y - innerHeight/2, 0, WORLD_H-innerHeight);
  }
  function screenToWorld(sx,sy){ return {x:sx+cam.x, y:sy+cam.y}; }

  // =========================
  // Toast
  // =========================
  let toastMsg="", toastT=0;
  function toast(m){ toastMsg=m; toastT=1.3; }

  // =========================
  // Collision
  // =========================
  function collidesCircle(x,y,r){
    const pts = [
      [x+r,y],[x-r,y],[x,y+r],[x,y-r],
      [x+r*0.7,y+r*0.7],[x-r*0.7,y+r*0.7],[x+r*0.7,y-r*0.7],[x-r*0.7,y-r*0.7]
    ];
    for(const [px,py] of pts){
      if(solidAt(px,py)) return true;
    }
    return false;
  }
  function moveWithCollide(obj, dx, dy, radius){
    let nx=obj.x+dx, ny=obj.y;
    if(!collidesCircle(nx, ny, radius)) obj.x=nx;
    nx=obj.x; ny=obj.y+dy;
    if(!collidesCircle(nx, ny, radius)) obj.y=ny;
  }

  // =========================
  // Shops UI
  // =========================
  const shopModal = document.getElementById("shopModal");
  const shopTitle = document.getElementById("shopTitle");
  let shopOpen = false;
  let currentShop = null;

  function openShop(shop){
    shopOpen = true;
    currentShop = shop;
    shopTitle.textContent = `${shop.name} â€” Spend your $$$`;
    shopModal.style.display = "block";
  }
  function closeShop(){
    shopOpen = false;
    currentShop = null;
    shopModal.style.display = "none";
  }

  document.getElementById("closeShop").onclick = closeShop;

  document.getElementById("buyHP").onclick = () => {
    if(!shopOpen) return;
    if(player.money < 100) return toast("Not enough money");
    player.money -= 100;
    player.hp = Math.min(100, player.hp + 30);
    toast("Health +30 âœ…");
  };

  document.getElementById("bribe").onclick = () => {
    if(!shopOpen) return;
    if(player.money < 200) return toast("Not enough money");
    player.money -= 200;
    player.wanted = Math.max(0, player.wanted - 1);
    toast("Wanted -1 âœ…");
  };

  document.getElementById("repair").onclick = () => {
    if(!shopOpen) return;
    if(player.money < 150) return toast("Not enough money");
    const car = cars.find(c=>c.driver);
    if(!car) return toast("Get in a car first");
    player.money -= 150;
    car.health = Math.min(100, car.health + 40);
    toast("Car repaired âœ…");
  };

  // =========================
  // Action
  // =========================
  function nearestCar(){
    let best=null, bd=1e9;
    for(const car of cars){
      const d = Math.hypot(car.x-player.x, car.y-player.y);
      if(d<bd){ bd=d; best=car; }
    }
    return {car:best, dist:bd};
  }

  function nearestShop(){
    let best=null, bd=1e9;
    for(const s of shops){
      const d=Math.hypot(player.x-s.x, player.y-s.y);
      if(d<bd){ bd=d; best=s; }
    }
    return {shop:best, dist:bd};
  }

  function action(){
    if(shopOpen){ closeShop(); return; }

    // If near shop, open it (only on foot)
    const {shop,dist:sd} = nearestShop();
    if(shop && sd < 26 && !player.inCar){
      openShop(shop);
      return;
    }

    // missions: touch checkpoint
    for(let i=missions.length-1;i>=0;i--){
      const m=missions[i];
      const d=Math.hypot(player.x-m.x, player.y-m.y);
      if(d < m.r+10){
        missions.splice(i,1);
        player.money += 150;
        player.wanted = Math.min(5, player.wanted + 0.5);
        toast("DELIVERY COMPLETE +$150 (Wanted +0.5)");
        newMission();
        return;
      }
    }

    // enter/exit car OR chaos
    const {car, dist} = nearestCar();
    if(!player.inCar){
      if(car && dist < 26){
        player.inCar=true;
        car.driver=true;
        car.ai=false;
        toast(`ENTER ${car.style.name}`);
      } else {
        player.wanted = Math.min(5, player.wanted + 0.6);
        toast("CHAOS! (Wanted up)");
      }
    } else {
      for(const car of cars){
        if(car.driver){
          car.driver=false;
          car.ai=true;
          player.inCar=false;
          player.x = car.x + 28;
          player.y = car.y;
          toast("EXIT CAR");
          break;
        }
      }
    }
  }

  function respawn(){
    player.hp=100;
    player.wanted = Math.max(0, player.wanted-1);
    for(const car of cars){ car.driver=false; if(!car.ai) car.ai=true; }
    player.inCar=false;
    closeShop();
    hardRespawnSafe();
    toast("RESPAWN (SAFE)");
  }

  // =========================
  // Effects
  // =========================
  function spark(x,y, n=10){
    for(let i=0;i<n;i++){
      particles.push({
        x,y, vx:rand(-140,140), vy:rand(-140,140),
        life:rand(0.15,0.45), hue: (Math.random()<0.5?170:330)
      });
    }
  }

  // =========================
  // Drawing: Buildings
  // =========================
  function shade(hex, amt){
    const r = parseInt(hex.slice(1,3),16);
    const g = parseInt(hex.slice(3,5),16);
    const b = parseInt(hex.slice(5,7),16);
    return `rgb(${clamp(r+amt,0,255)|0},${clamp(g+amt,0,255)|0},${clamp(b+amt,0,255)|0})`;
  }

  function drawBuilding(b, t){
    const shx=0.6, shy=0.9;
    const shLen=b.height*0.9;

    ctx.fillStyle = PAL.shadowDeep;
    ctx.beginPath();
    ctx.moveTo(b.x, b.y + b.h);
    ctx.lineTo(b.x + b.w, b.y + b.h);
    ctx.lineTo(b.x + b.w + shx*shLen, b.y + b.h + shy*shLen);
    ctx.lineTo(b.x + shx*shLen, b.y + b.h + shy*shLen);
    ctx.closePath();
    ctx.fill();

    const rx = b.x - b.lift;
    const ry = b.y - b.lift;

    ctx.fillStyle = b.wall;
    ctx.beginPath();
    ctx.moveTo(b.x + b.w, b.y);
    ctx.lineTo(rx + b.w, ry);
    ctx.lineTo(rx + b.w, ry + b.h);
    ctx.lineTo(b.x + b.w, b.y + b.h);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = shade(b.wall, -12);
    ctx.beginPath();
    ctx.moveTo(b.x, b.y + b.h);
    ctx.lineTo(rx, ry + b.h);
    ctx.lineTo(rx + b.w, ry + b.h);
    ctx.lineTo(b.x + b.w, b.y + b.h);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = b.roof;
    rectPix(rx, ry, b.w, b.h);

    ctx.strokeStyle="rgba(0,0,0,0.35)";
    ctx.lineWidth=1;
    ctx.strokeRect(rx|0, ry|0, b.w|0, b.h|0);

    if(b.detail==="windows"){
      for(let y=ry+3; y<ry+b.h-3; y+=6){
        for(let x=rx+3; x<rx+b.w-3; x+=6){
          ctx.fillStyle = ((x+y)&8) ? "rgba(255,255,255,0.10)" : "rgba(60,255,210,0.07)";
          rectPix(x, y, 2, 2);
        }
      }
    } else if(b.detail==="neon"){
      const pulse = 0.6 + 0.4*Math.sin(t*5 + (b.x+b.y)*0.01);
      ctx.fillStyle = `rgba(255,77,109,${0.16+0.18*pulse})`;
      rectPix(rx+2, ry+2, b.w-4, 2);
      ctx.fillStyle = `rgba(60,255,210,${0.14+0.16*pulse})`;
      rectPix(rx+2, ry+b.h-4, b.w-4, 2);
    }
  }

  function drawCar(car){
    ctx.save();
    ctx.translate(car.x, car.y);
    ctx.rotate(car.a);

    ctx.fillStyle = "rgba(0,0,0,0.28)";
    rectPix(-12, 7, 24, 6);

    ctx.fillStyle = car.style.body;
    rectPix(-12, -7, 24, 14);

    ctx.fillStyle = "rgba(255,255,255,0.10)";
    rectPix(-10, -6, 20, 3);

    ctx.fillStyle = car.style.roof;
    rectPix(-6, -3, 12, 6);

    ctx.fillStyle = car.style.trim;
    rectPix(-11, -9, 6, 3);
    rectPix(5, -9, 6, 3);
    rectPix(-11, 6, 6, 3);
    rectPix(5, 6, 6, 3);

    ctx.fillStyle = "rgba(255,255,200,0.65)";
    rectPix(10, -5, 2, 3);
    rectPix(10, 2, 2, 3);

    if(handbrake || car.skid>0.25){
      ctx.fillStyle = "rgba(255,77,109,0.85)";
      rectPix(-12, -5, 2, 3);
      rectPix(-12, 2, 2, 3);
    }

    if(car.driver){
      ctx.fillStyle = "rgba(60,255,210,0.95)";
      rectPix(-1, -1, 2, 2);
    }

    const dmg = 1 - car.health/100;
    if(dmg>0.2){
      ctx.fillStyle="rgba(0,0,0,0.25)";
      rectPix(-8, -2, 6, 1);
      rectPix(1, 3, 7, 1);
    }
    if(dmg>0.6){
      ctx.fillStyle="rgba(255,255,255,0.10)";
      rectPix(-2, -6, 4, 1);
    }

    ctx.restore();
  }

  function drawPlayer(t){
    ctx.save();
    ctx.translate(player.x, player.y);

    ctx.fillStyle="rgba(0,0,0,0.22)";
    circlePix(0, 8, 6);

    ctx.fillStyle="rgba(0,0,0,0.35)";
    rectPix(-4, 2, 3, 4);
    rectPix(1, 2, 3, 4);

    ctx.fillStyle="#3cffcc";
    rectPix(-5, -8, 10, 12);

    ctx.fillStyle="rgba(0,0,0,0.18)";
    rectPix(-5, -2, 10, 1);

    ctx.fillStyle="#ffd6a5";
    rectPix(-4, -14, 8, 6);

    const blink = (Math.sin(t*6)*0.5+0.5);
    ctx.fillStyle=`rgba(0,0,0,${0.35+0.2*blink})`;
    rectPix(-3, -12, 6, 2);

    ctx.restore();
  }

  function drawLamp(l){
    ctx.fillStyle="rgba(255,240,190,0.06)";
    circlePix(l.x, l.y, 18);
    ctx.fillStyle="rgba(0,0,0,0.35)";
    rectPix(l.x-1, l.y-8, 2, 10);
    ctx.fillStyle="rgba(255,240,190,0.6)";
    rectPix(l.x-2, l.y-10, 4, 3);
  }

  function drawShop(s,t){
    const pulse = 0.6 + 0.4*Math.sin(t*6 + (s.x+s.y)*0.01);
    ctx.save();
    ctx.translate(s.x, s.y);
    ctx.fillStyle=`rgba(255,77,109,${0.10+0.18*pulse})`;
    ctx.beginPath(); ctx.arc(0,0,s.r+6,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle="rgba(255,255,255,0.15)";
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(0,0,s.r,0,Math.PI*2); ctx.stroke();
    ctx.fillStyle="rgba(255,255,255,0.8)";
    rectPix(-5,-2,10,4);
    rectPix(-2,-5,4,10);
    ctx.restore();
  }

  // =========================
  // Update
  // =========================
  let last=performance.now();
  function tick(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last=now;

    update(dt);
    render(now/1000);
    requestAnimationFrame(tick);
  }

  function update(dt){
    if(shopOpen){
      // freeze movement while shopping
      if(toastT>0) toastT -= dt;
      updateCam();
      return;
    }

    player.wanted = Math.max(0, player.wanted - dt*0.03);

    const targetCops = Math.floor(player.wanted*2);
    while(cops.length < targetCops) spawnCop(player.x + rand(-320,320), player.y + rand(-320,320));
    while(cops.length > targetCops) cops.pop();

    let mx=0,my=0;
    if(keys.has("w")||keys.has("arrowup")) my-=1;
    if(keys.has("s")||keys.has("arrowdown")) my+=1;
    if(keys.has("a")||keys.has("arrowleft")) mx-=1;
    if(keys.has("d")||keys.has("arrowright")) mx+=1;
    mx += joyState.dx; my += joyState.dy;

    const mag = Math.hypot(mx,my);
    if(mag>1e-6){ mx/=mag; my/=mag; }

    if(player.inCar){
      const car = cars.find(c=>c.driver);
      if(car){
        let steerX = mx, steerY = my;

        if(matchMedia("(pointer:fine)").matches){
          const w = screenToWorld(pointer.x, pointer.y);
          steerX = w.x - car.x;
          steerY = w.y - car.y;
          const d = Math.hypot(steerX, steerY) || 1;
          steerX/=d; steerY/=d;
        } else if(Math.abs(steerX)+Math.abs(steerY) < 0.08){
          steerX = Math.cos(car.a);
          steerY = Math.sin(car.a);
        }

        const accel = handbrake ? 160 : 620;
        car.spd += accel*dt;
        car.spd *= handbrake ? (1-7.5*dt) : (1-2.6*dt);
        car.spd = Math.min(car.spd, handbrake?160:320);

        const targetA = Math.atan2(steerY, steerX);
        let da = targetA - car.a;
        while(da>Math.PI) da-=Math.PI*2;
        while(da<-Math.PI) da+=Math.PI*2;
        car.a += clamp(da, -3.8*dt, 3.8*dt);

        car.skid = clamp(car.skid + (handbrake?dt*2.2:-dt*2.2), 0, 1);

        const dx = Math.cos(car.a)*car.spd*dt;
        const dy = Math.sin(car.a)*car.spd*dt;

        const bx=car.x, by=car.y;
        moveWithCollide(car, dx, dy, 10);

        const moved = Math.hypot(car.x-bx, car.y-by);
        if(moved < Math.hypot(dx,dy)*0.3 && car.spd>140){
          car.health = Math.max(0, car.health - 30*dt);
          spark(car.x, car.y, 12);
          player.wanted = Math.min(5, player.wanted + 0.08);
        }

        const tt = tileAt(car.x, car.y);
        if(tt===2) player.wanted = Math.min(5, player.wanted + dt*0.04);
        if(tt===4) player.wanted = Math.min(5, player.wanted + dt*0.07);

        player.x=car.x; player.y=car.y;

        if(car.health<=0){
          car.health=0; car.driver=false; car.ai=true;
          player.inCar=false;
          toast("CAR WRECKED ðŸ’¥");
        }
      }
    } else {
      const spd=150;
      moveWithCollide(player, mx*spd*dt, my*spd*dt, player.r);
    }

    // Traffic AI (road-locked)
    for(const car of cars){
      if(car.driver || !car.ai) continue;

      const node = roadNodes[car.node];
      if(!node) continue;

      // if not currently on road, force recovery to nearest road node
      const onRoad = tileAt(car.x,car.y)===1;
      const target = onRoad ? node : nearestRoadNode(car.x,car.y);

      let dx = target.x - car.x, dy = target.y - car.y;
      let d = Math.hypot(dx,dy) || 1;
      dx/=d; dy/=d;

      const targetA = Math.atan2(dy, dx);
      let da = targetA - car.a;
      while(da>Math.PI) da-=Math.PI*2;
      while(da<-Math.PI) da+=Math.PI*2;
      car.a += clamp(da, -2.8*dt, 2.8*dt);

      // Slow down if off-road
      const desired = onRoad ? 150 : 90;
      car.spd += (desired - car.spd) * (1 - Math.pow(0.01, dt));
      car.spd = clamp(car.spd, 50, onRoad?175:120);

      const bx=car.x, by=car.y;
      moveWithCollide(car, Math.cos(car.a)*car.spd*dt, Math.sin(car.a)*car.spd*dt, 10);

      // If ended up off-road, gently nudge back toward target
      if(tileAt(car.x,car.y)!==1){
        car.x += dx * 30 * dt;
        car.y += dy * 30 * dt;
      }

      // stuck -> new node
      if(Math.hypot(car.x-bx, car.y-by) < 1.0){
        car.node = (Math.random()*roadNodes.length)|0;
      }

      if(d < 20){
        car.node = (car.node + randi(10, 80)) % roadNodes.length;
      }
    }

    // Cops chase
    for(const cop of cops){
      const dx=player.x-cop.x, dy=player.y-cop.y;
      const d=Math.hypot(dx,dy) || 1;
      moveWithCollide(cop, (dx/d)*cop.spd*dt, (dy/d)*cop.spd*dt, cop.r);
      if(d<18){
        player.hp = Math.max(0, player.hp - 18*dt);
        if(player.hp<=0){ toast("WASTED ðŸ’€"); respawn(); }
      }
    }

    // Missions
    for(let i=missions.length-1;i>=0;i--){
      const m=missions[i];
      const d=Math.hypot(player.x-m.x, player.y-m.y);
      m.t += dt;
      if(d < m.r+8){
        missions.splice(i,1);
        player.money += 150;
        player.wanted = Math.min(5, player.wanted + 0.5);
        toast("DELIVERY COMPLETE +$150 (Wanted +0.5)");
        newMission();
      }
    }

    // Particles
    for(let i=particles.length-1;i>=0;i--){
      const p=particles[i];
      p.x += p.vx*dt; p.y += p.vy*dt;
      p.vx *= (1-4*dt); p.vy *= (1-4*dt);
      p.life -= dt;
      if(p.life<=0) particles.splice(i,1);
    }

    if(toastT>0) toastT -= dt;
    updateCam();
  }

  // =========================
  // Render
  // =========================
  function render(t){
    ctx.fillStyle = PAL.sky;
    ctx.fillRect(0,0,innerWidth,innerHeight);

    ctx.save();
    ctx.translate(-cam.x, -cam.y);

    const x0 = Math.max(0, ((cam.x)/TILE|0)-2);
    const y0 = Math.max(0, ((cam.y)/TILE|0)-2);
    const x1 = Math.min(MAP_W-1, ((cam.x+innerWidth)/TILE|0)+2);
    const y1 = Math.min(MAP_H-1, ((cam.y+innerHeight)/TILE|0)+2);

    for(let ty=y0; ty<=y1; ty++){
      const py = ty*TILE;
      for(let tx=x0; tx<=x1; tx++){
        const px = tx*TILE;
        const tId = map[idx(tx,ty)];

        if(tId===0) ctx.fillStyle = ((tx+ty)&1) ? PAL.grassA : PAL.grassB;
        else if(tId===1) ctx.fillStyle = ((tx^ty)&3) ? PAL.roadA : PAL.roadB;
        else if(tId===2) ctx.fillStyle = ((tx+ty)&1) ? PAL.sideA : PAL.sideB;
        else if(tId===3) ctx.fillStyle = ((tx+ty)&1) ? PAL.waterA : PAL.waterB;
        else if(tId===5) ctx.fillStyle = "#2a2630";
        else ctx.fillStyle = "#10131d";

        rectPix(px,py,TILE,TILE);

        if(tId===1 && ((tx+ty)&3)===0){
          ctx.fillStyle="rgba(255,255,255,0.06)";
          rectPix(px+7, py+7, 2, 2);
        }
        if(tId===2 && ((tx*7+ty*11)&15)===0){
          ctx.fillStyle="rgba(0,0,0,0.10)";
          rectPix(px+3, py+10, 6, 1);
        }
        if(tId===3 && ((tx*13+ty*5)&15)===0){
          ctx.fillStyle="rgba(60,160,255,0.08)";
          rectPix(px+4, py+6, 2, 2);
        }
      }
    }

    for(const l of lamps){
      if(l.x < cam.x-40 || l.x > cam.x+innerWidth+40) continue;
      if(l.y < cam.y-40 || l.y > cam.y+innerHeight+40) continue;
      drawLamp(l);
    }

    // shops
    for(const s of shops) drawShop(s,t);

    // missions
    for(const m of missions){
      const pulse = 0.6 + 0.4*Math.sin((t+m.t)*6);
      ctx.save();
      ctx.translate(m.x, m.y);
      ctx.strokeStyle="rgba(60,255,210,0.9)";
      ctx.lineWidth=3;
      ctx.beginPath(); ctx.arc(0,0, m.r + pulse*5, 0, Math.PI*2); ctx.stroke();
      ctx.fillStyle="rgba(60,255,210,0.22)";
      ctx.beginPath(); ctx.arc(0,0, m.r, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    // buildings sorted by y
    const viewB=[];
    for(const b of buildings){
      if(b.x+b.w < cam.x-120 || b.x > cam.x+innerWidth+120) continue;
      if(b.y+b.h < cam.y-120 || b.y > cam.y+innerHeight+120) continue;
      viewB.push(b);
    }
    viewB.sort((a,b)=> (a.y+a.h) - (b.y+b.h));
    for(const b of viewB) drawBuilding(b, t);

    // cars
    for(const car of cars){
      if(car.skid>0.28 && (car.driver || !car.ai)){
        ctx.fillStyle="rgba(0,0,0,0.10)";
        rectPix(car.x - Math.cos(car.a)*10 - 2, car.y - Math.sin(car.a)*10 - 2, 4, 4);
      }
    }
    for(const car of cars) drawCar(car);

    // cops
    for(const cop of cops){
      ctx.save();
      ctx.translate(cop.x, cop.y);
      ctx.fillStyle="#3b82f6";
      circlePix(0,0,cop.r);
      ctx.fillStyle="rgba(255,255,255,0.7)";
      rectPix(-4,-8,8,3);
      ctx.restore();
    }

    // sparks
    for(const p of particles){
      ctx.globalAlpha = clamp(p.life*3,0,1);
      ctx.fillStyle = `rgba(${p.hue===170?60:255},${p.hue===170?255:77},${p.hue===170?210:109},0.9)`;
      rectPix(p.x-1,p.y-1,2,2);
      ctx.globalAlpha=1;
    }

    drawPlayer(t);

    ctx.restore();

    // UI text
    topEl.textContent =
      `LAZARO WORLD â€” HP ${player.hp|0} â€¢ $${player.money} â€¢ Wanted ${player.wanted.toFixed(1)} â€¢ ` +
      `${player.inCar ? "DRIVING (E exit) â€¢ Space/BRAKE drift" : "ON FOOT (E enter car / shop)"} â€¢ G remix city`;

    // nearest shop hint
    const {shop,dist} = nearestShop();
    const shopHint = (shop && dist<70 && !player.inCar) ? `Near ${shop.name}: Press E` : "";

    hudEl.innerHTML =
      `<b>Desktop:</b> WASD â€¢ E action â€¢ R respawn â€¢ Space brake â€¢ G remix â€¢ ESC close shop<br>`+
      `<b>Phone:</b> joystick â€¢ ACTION â€¢ BRAKE<br>`+
      `<b>Shops:</b> go to pink marker + press E â€¢ ${shopHint}`;

    if(toastT>0){
      ctx.save();
      ctx.globalAlpha = Math.min(1, toastT);
      ctx.fillStyle="rgba(0,0,0,0.55)";
      const w = Math.min(620, innerWidth-40);
      const x = (innerWidth-w)/2;
      ctx.fillRect(x, 60, w, 44);
      ctx.fillStyle=PAL.text;
      ctx.font="900 15px system-ui";
      ctx.textAlign="center";
      ctx.fillText(toastMsg, innerWidth/2, 88);
      ctx.restore();
    }

    drawMini();
  }

  function drawMini(){
    mctx.clearRect(0,0,mini.width,mini.height);
    mctx.fillStyle="rgba(0,0,0,0.25)";
    mctx.fillRect(0,0,mini.width,mini.height);

    const sx = mini.width / WORLD_W;
    const sy = mini.height / WORLD_H;

    const step = 7;
    for(let y=0;y<MAP_H;y+=step){
      for(let x=0;x<MAP_W;x+=step){
        const t = map[idx(x,y)];
        if(t===1) mctx.fillStyle="rgba(255,255,255,0.10)";
        else if(t===4) mctx.fillStyle="rgba(0,0,0,0.18)";
        else if(t===3) mctx.fillStyle="rgba(60,160,255,0.12)";
        else continue;
        mctx.fillRect(x*TILE*sx, y*TILE*sy, step*TILE*sx, step*TILE*sy);
      }
    }

    // shops
    mctx.fillStyle="rgba(255,77,109,0.75)";
    for(const s of shops){
      mctx.fillRect(s.x*sx-2, s.y*sy-2, 4, 4);
    }

    // missions
    mctx.strokeStyle="rgba(60,255,210,0.6)";
    for(const m of missions){
      mctx.beginPath();
      mctx.arc(m.x*sx, m.y*sy, 5, 0, Math.PI*2);
      mctx.stroke();
    }

    // cops
    mctx.fillStyle="rgba(59,130,246,0.9)";
    for(const cop of cops){
      mctx.fillRect(cop.x*sx-1, cop.y*sy-1, 2, 2);
    }

    // player
    mctx.fillStyle="rgba(60,255,210,0.9)";
    mctx.fillRect(player.x*sx-2, player.y*sy-2, 4, 4);
  }

  // Start
  hardRespawnSafe();  // âœ… safe spawn always
  updateCam();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
