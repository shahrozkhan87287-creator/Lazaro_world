<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>LAZARO WORLD — Pixel GTA</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#070a12;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  canvas{width:100vw;height:100vh;display:block;touch-action:none;image-rendering:pixelated}

  /* UI */
  .ui{position:fixed;inset:0;pointer-events:none;color:#fff}
  .top{position:fixed;left:12px;right:12px;top:12px;padding:10px 12px;border-radius:16px;
    background:rgba(0,0,0,.42);border:1px solid rgba(255,255,255,.14);backdrop-filter:blur(10px);
    font-weight:900;letter-spacing:.4px}
  .hud{position:fixed;left:12px;bottom:12px;max-width:min(920px,86vw);padding:10px 12px;border-radius:16px;
    background:rgba(0,0,0,.42);border:1px solid rgba(255,255,255,.14);backdrop-filter:blur(10px);
    font-size:12px;line-height:1.35}

  /* Setup overlay */
  .panel{
    pointer-events:auto;
    position:fixed;left:12px;top:64px;right:12px;
    max-width:1100px;margin:auto;
    border-radius:18px;
    background:rgba(0,0,0,.62);
    border:1px solid rgba(255,255,255,.14);
    backdrop-filter:blur(10px);
    padding:12px;
  }
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
  .btn{
    pointer-events:auto;
    border-radius:14px;padding:10px 12px;
    border:1px solid rgba(255,255,255,.16);
    background:rgba(255,255,255,.06);
    color:#fff;font-weight:900
  }
  .btn:active{transform:scale(.99)}
  .pill{
    border:1px solid rgba(255,255,255,.16);
    background:rgba(255,255,255,.06);
    padding:8px 10px;border-radius:999px;font-weight:800;font-size:12px
  }
  .step{font-weight:950}
  .preview{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .swatch{
    width:46px;height:46px;border-radius:12px;
    border:1px solid rgba(255,255,255,.18);
    background:rgba(255,255,255,.04);
    display:flex;align-items:center;justify-content:center;
    font-size:10px;font-weight:900;color:rgba(255,255,255,.85);
    overflow:hidden;
  }
  .sub{opacity:.85}

  /* Mobile controls */
  #joy{pointer-events:auto;position:fixed;left:14px;bottom:145px;width:150px;height:150px;border-radius:999px;
    background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);backdrop-filter:blur(8px)}
  #knob{position:absolute;left:50%;top:50%;width:64px;height:64px;transform:translate(-50%,-50%);
    border-radius:999px;background:rgba(255,255,255,.14);border:1px solid rgba(255,255,255,.18)}
  .mBtn{pointer-events:auto;position:fixed;right:14px;border-radius:18px;padding:14px 16px;
    border:1px solid rgba(255,255,255,.14);background:rgba(0,0,0,.42);color:#fff;font-weight:950}
  .mBtn:active{transform:scale(.98)}
  #action{bottom:18px}
  #brake{bottom:86px}
  @media (pointer:fine){#joy,.mBtn{display:none}}
</style>
</head>
<body>
<canvas id="c"></canvas>

<div class="ui">
  <div class="top" id="top">LAZARO WORLD — Loading…</div>
  <div class="hud" id="hud"></div>

  <div class="panel" id="setup" style="display:none">
    <div class="row">
      <div class="pill">
        <span class="step" id="stepText">Step 1/4</span>
        <span class="sub" id="stepDesc">Click a PAVEMENT tile (flat ground)</span>
      </div>
      <div class="row" style="gap:8px">
        <button class="btn" id="skip">Use defaults</button>
        <button class="btn" id="reset">Reset picks</button>
        <button class="btn" id="close">Hide setup</button>
      </div>
    </div>
    <div class="row" style="margin-top:10px;gap:10px">
      <div class="preview">
        <div class="swatch" id="swP">PAV</div>
        <div class="swatch" id="swR">ROAD</div>
        <div class="swatch" id="swG">PARK</div>
        <div class="swatch" id="swW">WATR</div>
        <div class="sub">Tip: Click the big tiles at the bottom of your sheet (roads/parking/grass/water).</div>
      </div>
      <div class="pill sub">
        Controls: WASD / arrows • E = enter/exit car • G = remix city
      </div>
    </div>
  </div>

  <div id="joy"><div id="knob"></div></div>
  <div class="mBtn" id="brake">BRAKE</div>
  <div class="mBtn" id="action">ACTION</div>
</div>

<script>
(() => {
  // --------------------------
  // Canvas + helpers
  // --------------------------
  const c = document.getElementById("c");
  const ctx = c.getContext("2d",{alpha:false});
  const topEl = document.getElementById("top");
  const hudEl = document.getElementById("hud");

  function resize(){
    const dpr = Math.max(1, Math.min(2, devicePixelRatio||1));
    c.width = (innerWidth*dpr)|0;
    c.height = (innerHeight*dpr)|0;
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener("resize", resize); resize();

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rand=(a,b)=>a+Math.random()*(b-a);

  // --------------------------
  // Assets
  // --------------------------
  const ASSETS = {};
  function loadImage(key, src){
    return new Promise((res, rej)=>{
      const img = new Image();
      img.onload=()=>{ASSETS[key]=img; res(img);};
      img.onerror=()=>rej(new Error("Failed to load: "+src));
      img.src=src;
    });
  }

  // --------------------------
  // Tile system (your sheet is an atlas, so we PICK tiles)
  // --------------------------
  const TILE = 32;     // world tile size
  const TILE_SRC = 32; // your sheet appears to be 32px tiles

  const STORAGE_KEY = "LW_TILES_V2";
  const steps = [
    {k:"pavement", label:"PAVEMENT", desc:"Click a PAVEMENT tile (flat ground)"},
    {k:"road",     label:"ROAD",     desc:"Click a ROAD tile (dark asphalt / lines)"},
    {k:"park",     label:"PARK",     desc:"Click a PARK/GRASS tile (green)"},
    {k:"water",    label:"WATER",    desc:"Click a WATER tile (blue)"},
  ];

  // Reasonable defaults (won't crash). If they look off, user can pick.
  const DEFAULT_PICK = { pavement: 0, road: 1, park: 2, water: 3 };

  let pick = null;      // {pavement,road,park,water}
  let picking = false;  // setup mode visible
  let step = 0;

  function loadPick(){
    try{
      const j = localStorage.getItem(STORAGE_KEY);
      if(!j) return null;
      const p = JSON.parse(j);
      for(const s of steps){
        if(typeof p[s.k] !== "number") return null;
      }
      return p;
    }catch{ return null; }
  }
  function savePick(p){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(p));
  }
  function resetPick(){
    localStorage.removeItem(STORAGE_KEY);
    pick = null;
    step = 0;
    picking = true;
    showSetup(true);
  }

  function sheetCols(){
    const img = ASSETS.tiles;
    return img ? Math.max(1, (img.width / TILE_SRC) | 0) : 1;
  }
  function drawTileFromSheet(tileIndex, dx, dy){
    const img = ASSETS.tiles;
    if(!img){ ctx.fillStyle="#222"; ctx.fillRect(dx,dy,TILE,TILE); return; }
    const cols = sheetCols();
    const sx = (tileIndex % cols) * TILE_SRC;
    const sy = ((tileIndex / cols) | 0) * TILE_SRC;
    if(sx+TILE_SRC>img.width || sy+TILE_SRC>img.height){
      ctx.fillStyle="#444"; ctx.fillRect(dx,dy,TILE,TILE); return;
    }
    ctx.drawImage(img, sx, sy, TILE_SRC, TILE_SRC, dx, dy, TILE, TILE);
  }

  // --------------------------
  // World (clean GTA-1-ish city)
  // --------------------------
  const MAP_W = 70, MAP_H = 50;
  const WORLD_W = MAP_W*TILE, WORLD_H = MAP_H*TILE;
  const map = new Uint8Array(MAP_W*MAP_H);
  const idx=(x,y)=>y*MAP_W+x;
  const inb=(x,y)=>x>=0&&y>=0&&x<MAP_W&&y<MAP_H;

  // 0 pavement, 1 road, 2 park, 3 water, 4 buildings (solid)
  function genCity(){
    map.fill(0);

    // water strip on right
    for(let y=0;y<MAP_H;y++){
      for(let x=MAP_W-8;x<MAP_W;x++) map[idx(x,y)] = 3;
    }

    // roads every 8 tiles
    for(let y=0;y<MAP_H;y++){
      for(let x=0;x<MAP_W-8;x++){
        if(x%8===0 || y%8===0) map[idx(x,y)] = 1;
      }
    }

    // parks sprinkled
    for(let i=0;i<180;i++){
      const x=(Math.random()*(MAP_W-12)|0)+2;
      const y=(Math.random()*(MAP_H-4)|0)+2;
      if(map[idx(x,y)]===0) map[idx(x,y)] = 2;
    }

    // buildings in blocks (avoid roads/water/parks)
    for(let i=0;i<280;i++){
      const bx=(Math.random()*(MAP_W-14)|0)+2;
      const by=(Math.random()*(MAP_H-6)|0)+2;
      const w=(2+Math.random()*4|0);
      const h=(2+Math.random()*4|0);

      let ok=true;
      for(let y=by;y<by+h;y++){
        for(let x=bx;x<bx+w;x++){
          if(!inb(x,y)) ok=false;
          const t = map[idx(x,y)];
          if(t!==0) ok=false;
          // keep away from roads
          if(inb(x+1,y) && map[idx(x+1,y)]===1) ok=false;
          if(inb(x-1,y) && map[idx(x-1,y)]===1) ok=false;
          if(inb(x,y+1) && map[idx(x,y+1)]===1) ok=false;
          if(inb(x,y-1) && map[idx(x,y-1)]===1) ok=false;
        }
      }
      if(!ok) continue;

      for(let y=by;y<by+h;y++){
        for(let x=bx;x<bx+w;x++) map[idx(x,y)] = 4;
      }
    }
  }

  function tileAt(px,py){
    const tx=(px/TILE)|0, ty=(py/TILE)|0;
    if(!inb(tx,ty)) return 4;
    return map[idx(tx,ty)];
  }
  function solidAt(px,py){
    const t=tileAt(px,py);
    return (t===4 || t===3);
  }

  // --------------------------
  // Input (keyboard + mobile)
  // --------------------------
  const keys=new Set();
  addEventListener("keydown", e=>{
    const k=e.key.toLowerCase();
    keys.add(k);
    if(k==="e") action();
    if(k==="g"){ genCity(); toast("CITY REMIX"); }
    if(k==="h"){ showSetup(!picking); }
  });
  addEventListener("keyup", e=>keys.delete(e.key.toLowerCase()));

  // joystick
  const joy=document.getElementById("joy");
  const knob=document.getElementById("knob");
  let joyState={id:null,active:false,dx:0,dy:0};
  function setKnob(dx,dy){
    const max=46;
    knob.style.transform=`translate(calc(-50% + ${dx*max}px), calc(-50% + ${dy*max}px))`;
  }
  function joyRect(){ return joy.getBoundingClientRect(); }
  joy.addEventListener("pointerdown", e=>{ joyState.id=e.pointerId; joyState.active=true; joy.setPointerCapture(e.pointerId); });
  joy.addEventListener("pointermove", e=>{
    if(!joyState.active||e.pointerId!==joyState.id) return;
    const r=joyRect(), cx=r.left+r.width/2, cy=r.top+r.height/2;
    const vx=e.clientX-cx, vy=e.clientY-cy;
    const max=r.width/2-10;
    joyState.dx=clamp(vx/max,-1,1); joyState.dy=clamp(vy/max,-1,1);
    setKnob(joyState.dx, joyState.dy);
  });
  function joyReset(){ joyState.active=false; joyState.id=null; joyState.dx=0; joyState.dy=0; setKnob(0,0); }
  joy.addEventListener("pointerup", e=>{ if(e.pointerId===joyState.id) joyReset(); });
  joy.addEventListener("pointercancel", joyReset);

  document.getElementById("action").addEventListener("click", ()=>action());
  let handbrake=false;
  document.getElementById("brake").addEventListener("pointerdown", ()=>handbrake=true);
  document.getElementById("brake").addEventListener("pointerup", ()=>handbrake=false);
  document.getElementById("brake").addEventListener("pointercancel", ()=>handbrake=false);

  // --------------------------
  // Entities
  // --------------------------
  const player={x:220,y:220,r:12,inCar:false};
  const cars=[];
  function spawnCar(x,y){ cars.push({x,y,a:0,spd:0,driver:false}); }
  for(let i=0;i<10;i++) spawnCar(rand(140,WORLD_W-360), rand(140,WORLD_H-140));

  function nearestCar(){
    let best=null, bd=1e9;
    for(const car of cars){
      const d=Math.hypot(car.x-player.x, car.y-player.y);
      if(d<bd){ bd=d; best=car; }
    }
    return {car:best,dist:bd};
  }

  function action(){
    const {car,dist}=nearestCar();
    if(!player.inCar){
      if(car && dist<44){ player.inCar=true; car.driver=true; toast("ENTER CAR"); }
      else toast("NO CAR CLOSE");
    }else{
      const c = cars.find(x=>x.driver);
      if(c){ c.driver=false; player.inCar=false; player.x=c.x+58; player.y=c.y; toast("EXIT CAR"); }
    }
  }

  // collision
  function collidesCircle(x,y,r){
    const pts=[[x+r,y],[x-r,y],[x,y+r],[x,y-r]];
    for(const [px,py] of pts){
      if(solidAt(px,py)) return true;
    }
    return false;
  }
  function moveWithCollide(obj,dx,dy,r){
    let nx=obj.x+dx, ny=obj.y;
    if(!collidesCircle(nx,ny,r)) obj.x=nx;
    nx=obj.x; ny=obj.y+dy;
    if(!collidesCircle(nx,ny,r)) obj.y=ny;
  }

  // camera
  const cam={x:0,y:0};
  function updateCam(){
    cam.x=clamp(player.x-innerWidth/2,0,Math.max(0,WORLD_W-innerWidth));
    cam.y=clamp(player.y-innerHeight/2,0,Math.max(0,WORLD_H-innerHeight));
  }

  // toast
  let toastMsg="", toastT=0;
  function toast(m){ toastMsg=m; toastT=1.2; }

  // draw car
  function drawCar(car){
    const img=ASSETS.carRed;
    const w=42,h=24;
    ctx.save();
    ctx.translate(car.x,car.y);
    ctx.rotate(car.a + Math.PI/2);
    ctx.globalAlpha=0.22;
    ctx.fillStyle="#000";
    ctx.fillRect(-w/2+2,-h/2+5,w,h);
    ctx.globalAlpha=1;
    if(img) ctx.drawImage(img,-w/2,-h/2,w,h);
    else { ctx.fillStyle="rgba(255,255,255,0.7)"; ctx.fillRect(-w/2,-h/2,w,h); }
    if(car.driver){
      ctx.fillStyle="rgba(60,255,210,0.95)";
      ctx.fillRect(-2,-2,4,4);
    }
    ctx.restore();
  }

  // --------------------------
  // Setup UI (the “fix everything” part)
  // --------------------------
  const setupEl = document.getElementById("setup");
  const stepText = document.getElementById("stepText");
  const stepDesc = document.getElementById("stepDesc");
  const swP = document.getElementById("swP");
  const swR = document.getElementById("swR");
  const swG = document.getElementById("swG");
  const swW = document.getElementById("swW");

  document.getElementById("reset").addEventListener("click", resetPick);
  document.getElementById("skip").addEventListener("click", ()=>{
    pick = {...DEFAULT_PICK};
    savePick(pick);
    picking = false;
    showSetup(false);
    toast("DEFAULT TILES SET");
  });
  document.getElementById("close").addEventListener("click", ()=>showSetup(false));

  function showSetup(on){
    picking = !!on;
    setupEl.style.display = picking ? "block" : "none";
  }

  function renderSwatch(el, tileIndex){
    // Draw a tiny preview of chosen tile inside the swatch
    const img = ASSETS.tiles;
    if(!img){ el.textContent = el.id; return; }
    const cols = sheetCols();
    const sx = (tileIndex % cols) * TILE_SRC;
    const sy = ((tileIndex / cols) | 0) * TILE_SRC;

    // Use CSS background image for easy preview
    el.style.backgroundImage = `url(${img.src})`;
    el.style.backgroundSize = `${img.width}px ${img.height}px`;
    el.style.backgroundPosition = `${-sx}px ${-sy}px`;
    el.style.backgroundRepeat = "no-repeat";
    el.textContent = "";
  }

  function updateSetupText(){
    const s = steps[step];
    stepText.textContent = `Step ${step+1}/4`;
    stepDesc.textContent = s ? s.desc : "Done";
  }

  // Click to pick tiles (works on phone too)
  c.addEventListener("pointerdown", (e)=>{
    if(!picking) return;

    // Draw the atlas at (ox, oy) in setup rendering. Must match.
    const ox = 20;
    const oy = 140; // below the panel
    const img = ASSETS.tiles;
    if(!img) return;

    const mx = e.clientX - ox;
    const my = e.clientY - oy;

    if(mx < 0 || my < 0 || mx >= img.width || my >= img.height) return;

    const cols = sheetCols();
    const tx = (mx / TILE_SRC) | 0;
    const ty = (my / TILE_SRC) | 0;
    const id = ty * cols + tx;

    if(!pick) pick = {};
    const key = steps[step].k;
    pick[key] = id;

    // Update swatches live
    if(key==="pavement") renderSwatch(swP, id);
    if(key==="road")     renderSwatch(swR, id);
    if(key==="park")     renderSwatch(swG, id);
    if(key==="water")    renderSwatch(swW, id);

    step++;
    if(step >= steps.length){
      savePick(pick);
      showSetup(false);
      toast("TILES SAVED ✅");
    } else {
      updateSetupText();
      toast(`Picked ${key.toUpperCase()} tile`);
    }
  });

  // --------------------------
  // Loop
  // --------------------------
  let last=performance.now();
  function tick(now){
    const dt=Math.min(0.033,(now-last)/1000);
    last=now;
    update(dt);
    render();
    requestAnimationFrame(tick);
  }

  function update(dt){
    // Freeze gameplay movement while picking
    if(picking){
      updateCam();
      if(toastT>0) toastT-=dt;
      return;
    }

    let mx=0,my=0;
    if(keys.has("w")||keys.has("arrowup")) my-=1;
    if(keys.has("s")||keys.has("arrowdown")) my+=1;
    if(keys.has("a")||keys.has("arrowleft")) mx-=1;
    if(keys.has("d")||keys.has("arrowright")) mx+=1;
    mx+=joyState.dx; my+=joyState.dy;

    const m=Math.hypot(mx,my);
    if(m>1e-6){ mx/=m; my/=m; }

    if(player.inCar){
      const car=cars.find(c=>c.driver);
      if(car){
        car.spd += (handbrake?120:720)*dt;
        car.spd *= handbrake ? (1-8*dt) : (1-2.6*dt);
        car.spd = Math.min(car.spd, handbrake?200:380);

        if(Math.abs(mx)+Math.abs(my)>0.06){
          const target=Math.atan2(my,mx);
          let da=target-car.a;
          while(da>Math.PI) da-=Math.PI*2;
          while(da<-Math.PI) da+=Math.PI*2;
          car.a += clamp(da,-3.8*dt,3.8*dt);
        }

        moveWithCollide(car, Math.cos(car.a)*car.spd*dt, Math.sin(car.a)*car.spd*dt, 14);
        player.x=car.x; player.y=car.y;
      }
    }else{
      moveWithCollide(player, mx*240*dt, my*240*dt, player.r);
    }

    updateCam();
    if(toastT>0) toastT-=dt;
  }

  function render(){
    ctx.fillStyle="#070a12";
    ctx.fillRect(0,0,innerWidth,innerHeight);

    // World
    ctx.save();
    ctx.translate(-cam.x,-cam.y);

    const x0=Math.max(0,((cam.x)/TILE|0)-2);
    const y0=Math.max(0,((cam.y)/TILE|0)-2);
    const x1=Math.min(MAP_W-1,((cam.x+innerWidth)/TILE|0)+2);
    const y1=Math.min(MAP_H-1,((cam.y+innerHeight)/TILE|0)+2);

    // If no pick yet, show pavement fallback
    const P = pick || DEFAULT_PICK;

    for(let ty=y0;ty<=y1;ty++){
      for(let tx=x0;tx<=x1;tx++){
        const t = map[idx(tx,ty)];
        let sheet = P.pavement;
        if(t===1) sheet = P.road;
        if(t===2) sheet = P.park;
        if(t===3) sheet = P.water;
        if(t===4) sheet = P.pavement; // buildings are "solid"; we tint them

        drawTileFromSheet(sheet, tx*TILE, ty*TILE);

        // buildings: visual height shading
        if(t===4){
          ctx.fillStyle="rgba(0,0,0,0.28)";
          ctx.fillRect(tx*TILE, ty*TILE, TILE, TILE);
          ctx.fillStyle="rgba(255,255,255,0.08)";
          ctx.fillRect(tx*TILE, ty*TILE, TILE, 5);
          ctx.fillRect(tx*TILE, ty*TILE, 5, TILE);
        }
      }
    }

    for(const car of cars) drawCar(car);

    // player
    ctx.save();
    ctx.translate(player.x,player.y);
    ctx.fillStyle="rgba(0,0,0,0.25)";
    ctx.beginPath(); ctx.arc(0,12,10,0,Math.PI*2); ctx.fill();
    ctx.fillStyle="#3cffcc"; ctx.fillRect(-7,-10,14,18);
    ctx.fillStyle="#ffd6a5"; ctx.fillRect(-6,-20,12,8);
    ctx.restore();

    ctx.restore();

    // Setup mode: draw the tilesheet clearly with a grid
    if(picking && ASSETS.tiles){
      const img = ASSETS.tiles;
      const ox = 20;
      const oy = 140;

      // dark panel behind atlas
      ctx.save();
      ctx.fillStyle="rgba(0,0,0,0.65)";
      ctx.fillRect(ox-10, oy-10, img.width+20, img.height+20);

      ctx.drawImage(img, ox, oy);

      // grid lines
      ctx.strokeStyle="rgba(255,255,255,0.18)";
      ctx.lineWidth=1;
      for(let x=0;x<=img.width;x+=TILE_SRC){
        ctx.beginPath(); ctx.moveTo(ox+x, oy); ctx.lineTo(ox+x, oy+img.height); ctx.stroke();
      }
      for(let y=0;y<=img.height;y+=TILE_SRC){
        ctx.beginPath(); ctx.moveTo(ox, oy+y); ctx.lineTo(ox+img.width, oy+y); ctx.stroke();
      }
      ctx.restore();
    }

    // Top + HUD
    if(picking){
      topEl.textContent = "LAZARO WORLD — Setup: Click tiles in the atlas (Press H to hide/show)";
      hudEl.innerHTML =
        `<b>Do this once:</b> Click tiles in order: PAVEMENT → ROAD → PARK → WATER<br>`+
        `<b>Buttons:</b> Use defaults / Reset picks / Hide setup<br>`+
        `<b>After setup:</b> WASD move • E enter/exit car • G remix city`;
    }else{
      topEl.textContent = "LAZARO WORLD — GTA-1 Style ✅ (Press H for setup / G remix)";
      hudEl.innerHTML =
        `<b>Move:</b> WASD / arrows (or joystick)<br>`+
        `<b>E / ACTION:</b> enter/exit car • <b>G:</b> new city • <b>H:</b> show setup<br>`+
        `<b>If visuals look wrong:</b> press H → Reset picks → pick better tiles.`;
    }

    if(toastT>0){
      ctx.save();
      ctx.globalAlpha=Math.min(1,toastT);
      ctx.fillStyle="rgba(0,0,0,0.55)";
      const w=Math.min(620,innerWidth-40);
      const x=(innerWidth-w)/2;
      ctx.fillRect(x,60,w,44);
      ctx.fillStyle="rgba(255,255,255,0.95)";
      ctx.font="900 15px system-ui";
      ctx.textAlign="center";
      ctx.fillText(toastMsg, innerWidth/2, 88);
      ctx.restore();
    }
  }

  // --------------------------
  // Start
  // --------------------------
  async function start(){
    try{
      await loadImage("tiles","assets/sTiles.png");
      await loadImage("carRed","assets/Vehicles/sRedCar.png");
    }catch(err){
      topEl.textContent = "LAZARO WORLD — asset load failed ❌";
      hudEl.textContent = String(err);
      return;
    }

    pick = loadPick();
    picking = !pick; // if no saved pick, show setup immediately
    document.getElementById("setup").style.display = picking ? "block" : "none";
    step = 0;
    updateSetupText();

    // If we have saved picks, render previews in the panel (so it looks “done”)
    if(pick){
      showSetup(false);
    }else{
      // show swatches if user already clicked something (they haven't yet)
      showSetup(true);
    }

    // Setup panel can still be opened with H even after saved
    function syncSetup(){
      document.getElementById("setup").style.display = picking ? "block" : "none";
      updateSetupText();
      if(pick){
        renderSwatch(swP, pick.pavement);
        renderSwatch(swR, pick.road);
        renderSwatch(swG, pick.park);
        renderSwatch(swW, pick.water);
      }
    }
    // Override showSetup to keep synced
    const _showSetup = showSetup;
    showSetup = (on)=>{ _showSetup(on); syncSetup(); };
    syncSetup();

    // Create city AFTER assets load
    genCity();

    requestAnimationFrame(tick);
  }

  start();
})();
</script>
</body>
</html>
