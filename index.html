<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>LAZARO WORLD — 2D GTA (Fixed)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#0b0f1e;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  canvas{width:100vw;height:100vh;display:block;touch-action:none;image-rendering:pixelated}
  .ui{position:fixed;inset:0;pointer-events:none;color:#fff}
  .bar{position:fixed;left:12px;right:12px;top:12px;padding:10px 12px;border-radius:16px;
    background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.14);backdrop-filter:blur(10px);font-weight:900}
  .hud{position:fixed;left:12px;bottom:12px;max-width:min(900px,86vw);padding:10px 12px;border-radius:16px;
    background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.14);backdrop-filter:blur(10px);font-size:12px;line-height:1.35}
  /* Mobile controls */
  #joy{pointer-events:auto;position:fixed;left:14px;bottom:130px;width:150px;height:150px;border-radius:999px;
    background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);backdrop-filter:blur(8px)}
  #knob{position:absolute;left:50%;top:50%;width:64px;height:64px;transform:translate(-50%,-50%);
    border-radius:999px;background:rgba(255,255,255,.14);border:1px solid rgba(255,255,255,.18)}
  .btn{pointer-events:auto;position:fixed;right:14px;border-radius:18px;padding:14px 16px;
    border:1px solid rgba(255,255,255,.14);background:rgba(0,0,0,.35);color:#fff;font-weight:950}
  .btn:active{transform:scale(.98)}
  #action{bottom:18px}
  #brake{bottom:86px}
  @media (pointer:fine){#joy,.btn{display:none}}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="ui">
  <div class="bar" id="bar">LAZARO WORLD — loading…</div>
  <div class="hud" id="hud"></div>
  <div id="joy"><div id="knob"></div></div>
  <div class="btn" id="brake">BRAKE</div>
  <div class="btn" id="action">ACTION</div>
</div>

<script>
(() => {
  // =========================
  // Canvas
  // =========================
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d",{alpha:false});
  const bar = document.getElementById("bar");
  const hud = document.getElementById("hud");
  function resize(){
    const dpr = Math.max(1, Math.min(2, devicePixelRatio||1));
    canvas.width = (innerWidth*dpr)|0;
    canvas.height = (innerHeight*dpr)|0;
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener("resize", resize); resize();

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rand=(a,b)=>a+Math.random()*(b-a);

  // =========================
  // Assets
  // =========================
  const ASSETS = {};
  function loadImage(key, src){
    return new Promise((res, rej)=>{
      const img = new Image();
      img.onload=()=>{ASSETS[key]=img; res(img);};
      img.onerror=()=>rej(new Error("Failed to load: "+src));
      img.src=src;
    });
  }

  // =========================
  // ✅ FIXED TILE SETTINGS
  // =========================
  // Your pack is 32px tiles. Using 16px created that “grid everywhere” look.
  const TILE = 32;      // world tile size
  const TILE_SRC = 32;  // source tile size in sTiles.png

  // These are *default guesses*. If any one looks off, only change these numbers.
  const SHEET = {
    pavement: 10,  // flat ground tile (NOT a grid/edge)
    road:     22,  // clean road tile
    park:     12,  // grass/park tile
    water:    50,  // water tile if exists (if wrong, it will still run)
    roof:     11   // used under building tint
  };

  function sheetCols(){
    const img = ASSETS.tiles;
    return img ? Math.max(1, (img.width / TILE_SRC) | 0) : 1;
  }

  function drawSheetTile(tileIndex, dx, dy){
    const img = ASSETS.tiles;
    if(!img){ ctx.fillStyle="#222"; ctx.fillRect(dx,dy,TILE,TILE); return; }
    const cols = sheetCols();
    const sx = (tileIndex % cols) * TILE_SRC;
    const sy = ((tileIndex / cols) | 0) * TILE_SRC;
    if(sx+TILE_SRC>img.width || sy+TILE_SRC>img.height){
      ctx.fillStyle="#444"; ctx.fillRect(dx,dy,TILE,TILE); return;
    }
    ctx.drawImage(img, sx, sy, TILE_SRC, TILE_SRC, dx, dy, TILE, TILE);
  }

  // =========================
  // Map (clean GTA-1 vibe)
  // =========================
  const MAP_W = 70, MAP_H = 50; // fewer tiles because 32px each
  const WORLD_W = MAP_W*TILE, WORLD_H = MAP_H*TILE;

  // 0 pavement, 1 road, 2 park, 3 water, 4 building(solid)
  const map = new Uint8Array(MAP_W*MAP_H);
  const idx=(x,y)=>y*MAP_W+x;
  const inb=(x,y)=>x>=0&&y>=0&&x<MAP_W&&y<MAP_H;

  function genCity(){
    map.fill(0);

    // water strip right side
    for(let y=0;y<MAP_H;y++){
      for(let x=MAP_W-8;x<MAP_W;x++) map[idx(x,y)] = 3;
    }

    // roads (every 8 tiles) — simple + clean
    for(let y=0;y<MAP_H;y++){
      for(let x=0;x<MAP_W-8;x++){
        if(x%8===0 || y%8===0) map[idx(x,y)] = 1;
      }
    }

    // parks sprinkled
    for(let i=0;i<170;i++){
      const x=(Math.random()*(MAP_W-12)|0)+2;
      const y=(Math.random()*(MAP_H-4)|0)+2;
      if(map[idx(x,y)]===0) map[idx(x,y)] = 2;
    }

    // buildings (avoid roads/water/parks)
    for(let i=0;i<260;i++){
      const bx=(Math.random()*(MAP_W-14)|0)+2;
      const by=(Math.random()*(MAP_H-6)|0)+2;
      const w=(2+Math.random()*4|0);
      const h=(2+Math.random()*4|0);

      let ok=true;
      for(let y=by;y<by+h;y++){
        for(let x=bx;x<bx+w;x++){
          if(!inb(x,y)) ok=false;
          const t = map[idx(x,y)];
          if(t!==0) ok=false;
          // keep away from roads
          if(inb(x+1,y) && map[idx(x+1,y)]===1) ok=false;
          if(inb(x-1,y) && map[idx(x-1,y)]===1) ok=false;
          if(inb(x,y+1) && map[idx(x,y+1)]===1) ok=false;
          if(inb(x,y-1) && map[idx(x,y-1)]===1) ok=false;
        }
      }
      if(!ok) continue;

      for(let y=by;y<by+h;y++){
        for(let x=bx;x<bx+w;x++) map[idx(x,y)] = 4;
      }
    }
  }
  genCity();

  function tileAt(px,py){
    const tx=(px/TILE)|0, ty=(py/TILE)|0;
    if(!inb(tx,ty)) return 4;
    return map[idx(tx,ty)];
  }
  function solidAt(px,py){
    const t=tileAt(px,py);
    return (t===4 || t===3);
  }

  // =========================
  // Input (keyboard + mobile joystick)
  // =========================
  const keys=new Set();
  addEventListener("keydown", e=>{
    const k=e.key.toLowerCase(); keys.add(k);
    if(k==="e") action();
    if(k==="g") { genCity(); toast("CITY REMIX"); }
  });
  addEventListener("keyup", e=>keys.delete(e.key.toLowerCase()));

  // joystick
  const joy=document.getElementById("joy");
  const knob=document.getElementById("knob");
  let joyState={id:null,active:false,dx:0,dy:0};
  function setKnob(dx,dy){
    const max=46;
    knob.style.transform=`translate(calc(-50% + ${dx*max}px), calc(-50% + ${dy*max}px))`;
  }
  function joyRect(){ return joy.getBoundingClientRect(); }
  joy.addEventListener("pointerdown", e=>{
    joyState.id=e.pointerId; joyState.active=true; joy.setPointerCapture(e.pointerId);
  });
  joy.addEventListener("pointermove", e=>{
    if(!joyState.active||e.pointerId!==joyState.id) return;
    const r=joyRect(), cx=r.left+r.width/2, cy=r.top+r.height/2;
    const vx=e.clientX-cx, vy=e.clientY-cy;
    const max=r.width/2-10;
    joyState.dx=clamp(vx/max,-1,1); joyState.dy=clamp(vy/max,-1,1);
    setKnob(joyState.dx, joyState.dy);
  });
  function joyReset(){ joyState.active=false; joyState.id=null; joyState.dx=0; joyState.dy=0; setKnob(0,0); }
  joy.addEventListener("pointerup", e=>{ if(e.pointerId===joyState.id) joyReset(); });
  joy.addEventListener("pointercancel", joyReset);

  // buttons
  document.getElementById("action").addEventListener("click", ()=>action());
  let handbrake=false;
  const brakeBtn=document.getElementById("brake");
  brakeBtn.addEventListener("pointerdown", ()=>handbrake=true);
  brakeBtn.addEventListener("pointerup", ()=>handbrake=false);
  brakeBtn.addEventListener("pointercancel", ()=>handbrake=false);

  // =========================
  // Entities
  // =========================
  const player={x:220,y:220,r:10,inCar:false};
  const cars=[];
  function spawnCar(x,y){ cars.push({x,y,a:0,spd:0,driver:false}); }
  for(let i=0;i<10;i++) spawnCar(rand(120,WORLD_W-340), rand(120,WORLD_H-120));

  function nearestCar(){
    let best=null, bd=1e9;
    for(const car of cars){
      const d=Math.hypot(car.x-player.x, car.y-player.y);
      if(d<bd){ bd=d; best=car; }
    }
    return {car:best,dist:bd};
  }

  function action(){
    const {car,dist}=nearestCar();
    if(!player.inCar){
      if(car && dist<40){ player.inCar=true; car.driver=true; toast("ENTER CAR"); }
      else toast("NO CAR CLOSE");
    }else{
      const c = cars.find(x=>x.driver);
      if(c){ c.driver=false; player.inCar=false; player.x=c.x+56; player.y=c.y; toast("EXIT CAR"); }
    }
  }

  // collision helpers
  function collidesCircle(x,y,r){
    const pts=[[x+r,y],[x-r,y],[x,y+r],[x,y-r]];
    for(const [px,py] of pts){
      if(solidAt(px,py)) return true;
    }
    return false;
  }
  function moveWithCollide(obj,dx,dy,r){
    let nx=obj.x+dx, ny=obj.y;
    if(!collidesCircle(nx,ny,r)) obj.x=nx;
    nx=obj.x; ny=obj.y+dy;
    if(!collidesCircle(nx,ny,r)) obj.y=ny;
  }

  // camera
  const cam={x:0,y:0};
  function updateCam(){
    cam.x=clamp(player.x-innerWidth/2,0,Math.max(0,WORLD_W-innerWidth));
    cam.y=clamp(player.y-innerHeight/2,0,Math.max(0,WORLD_H-innerHeight));
  }

  // toast
  let toastMsg="", toastT=0;
  function toast(m){ toastMsg=m; toastT=1.2; }

  // draw car png
  function drawCar(car){
    const img=ASSETS.carRed;
    const w=40,h=22;
    ctx.save();
    ctx.translate(car.x,car.y);
    ctx.rotate(car.a + Math.PI/2); // rotate sprite alignment
    ctx.globalAlpha=0.22;
    ctx.fillStyle="#000";
    ctx.fillRect(-w/2+2,-h/2+5,w,h);
    ctx.globalAlpha=1;
    if(img) ctx.drawImage(img,-w/2,-h/2,w,h);
    else { ctx.fillStyle="rgba(255,255,255,0.7)"; ctx.fillRect(-w/2,-h/2,w,h); }
    if(car.driver){
      ctx.fillStyle="rgba(60,255,210,0.95)";
      ctx.fillRect(-2,-2,4,4);
    }
    ctx.restore();
  }

  // =========================
  // Loop
  // =========================
  let last=performance.now();
  function tick(now){
    const dt=Math.min(0.033,(now-last)/1000);
    last=now;
    update(dt);
    render();
    requestAnimationFrame(tick);
  }

  function update(dt){
    let mx=0,my=0;
    if(keys.has("w")||keys.has("arrowup")) my-=1;
    if(keys.has("s")||keys.has("arrowdown")) my+=1;
    if(keys.has("a")||keys.has("arrowleft")) mx-=1;
    if(keys.has("d")||keys.has("arrowright")) mx+=1;
    mx+=joyState.dx; my+=joyState.dy;

    const m=Math.hypot(mx,my);
    if(m>1e-6){ mx/=m; my/=m; }

    if(player.inCar){
      const car=cars.find(c=>c.driver);
      if(car){
        // accelerate + steering
        car.spd += (handbrake?120:680)*dt;
        car.spd *= handbrake ? (1-8*dt) : (1-2.5*dt);
        car.spd = Math.min(car.spd, handbrake?180:360);

        if(Math.abs(mx)+Math.abs(my)>0.06){
          const target=Math.atan2(my,mx);
          let da=target-car.a;
          while(da>Math.PI) da-=Math.PI*2;
          while(da<-Math.PI) da+=Math.PI*2;
          car.a += clamp(da,-3.8*dt,3.8*dt);
        }

        moveWithCollide(car, Math.cos(car.a)*car.spd*dt, Math.sin(car.a)*car.spd*dt, 14);
        player.x=car.x; player.y=car.y;
      }
    }else{
      moveWithCollide(player, mx*220*dt, my*220*dt, player.r);
    }

    updateCam();
    if(toastT>0) toastT-=dt;
  }

  function render(){
    ctx.fillStyle="#0b0f1e";
    ctx.fillRect(0,0,innerWidth,innerHeight);

    ctx.save();
    ctx.translate(-cam.x,-cam.y);

    // draw visible tiles
    const x0=Math.max(0,((cam.x)/TILE|0)-2);
    const y0=Math.max(0,((cam.y)/TILE|0)-2);
    const x1=Math.min(MAP_W-1,((cam.x+innerWidth)/TILE|0)+2);
    const y1=Math.min(MAP_H-1,((cam.y+innerHeight)/TILE|0)+2);

    for(let ty=y0;ty<=y1;ty++){
      for(let tx=x0;tx<=x1;tx++){
        const t = map[idx(tx,ty)];
        let sheet = SHEET.pavement;
        if(t===1) sheet = SHEET.road;
        if(t===2) sheet = SHEET.park;
        if(t===3) sheet = SHEET.water;
        if(t===4) sheet = SHEET.roof;
        drawSheetTile(sheet, tx*TILE, ty*TILE);

        // buildings: add simple height shading so they look tall
        if(t===4){
          ctx.fillStyle="rgba(0,0,0,0.25)";
          ctx.fillRect(tx*TILE, ty*TILE, TILE, TILE);
          ctx.fillStyle="rgba(255,255,255,0.06)";
          ctx.fillRect(tx*TILE, ty*TILE, TILE, 5);
          ctx.fillRect(tx*TILE, ty*TILE, 5, TILE);
        }
      }
    }

    // cars
    for(const car of cars) drawCar(car);

    // player (placeholder)
    ctx.save();
    ctx.translate(player.x,player.y);
    ctx.fillStyle="rgba(0,0,0,0.25)";
    ctx.beginPath(); ctx.arc(0,12,10,0,Math.PI*2); ctx.fill();
    ctx.fillStyle="#3cffcc"; ctx.fillRect(-7,-10,14,18);
    ctx.fillStyle="#ffd6a5"; ctx.fillRect(-6,-20,12,8);
    ctx.restore();

    ctx.restore();

    // UI
    bar.textContent="LAZARO WORLD — Fixed City ✅  (Press G to remix)";
    hud.innerHTML =
      `<b>Move:</b> WASD / arrows (or joystick on phone)<br>`+
      `<b>Action:</b> E or ACTION = enter/exit car<br>`+
      `<b>Remix:</b> G = new city layout<br>`+
      `<b>If ground/road look wrong:</b> change 4 numbers in SHEET (pavement/road/park/water).`;

    if(toastT>0){
      ctx.save();
      ctx.globalAlpha=Math.min(1,toastT);
      ctx.fillStyle="rgba(0,0,0,0.55)";
      const w=Math.min(620,innerWidth-40);
      const x=(innerWidth-w)/2;
      ctx.fillRect(x,60,w,44);
      ctx.fillStyle="rgba(255,255,255,0.95)";
      ctx.font="900 15px system-ui";
      ctx.textAlign="center";
      ctx.fillText(toastMsg, innerWidth/2, 88);
      ctx.restore();
    }
  }

  // =========================
  // Start
  // =========================
  async function start(){
    try{
      await loadImage("tiles","assets/sTiles.png");
      await loadImage("carRed","assets/Vehicles/sRedCar.png");
      bar.textContent="LAZARO WORLD — Loaded ✅";
    }catch(err){
      bar.textContent="LAZARO WORLD — asset load failed ❌";
      hud.textContent=String(err);
    }
    requestAnimationFrame(tick);
  }
  start();
})();
</script>
</body>
</html>
